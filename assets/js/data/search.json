[ { "title": "LNMP MySQL 設定 error_log", "url": "/posts/Mysql-set-error-log-30/", "categories": "MySQL", "tags": "MySQL", "date": "2023-03-30 00:00:00 +0800", "snippet": "使用的環境 系統與使用工具 Centos 7.6 mysql Ver 8.0.13 一、設定 error_log 遇到問題如果 LNMP 安裝的 MySQL 在 /etc/my.cnf 當中設定 log_error=/var/log/mysql/error.log，會遇到以下錯誤且無法重新啟動成功。mysql.serviceJob for mysql.service failed because the control process exited with error code. See &quot;systemctl status mysql.service&quot; and &quot;journalctl -xe&quot; for details.因為 LNMP 在安裝 MySQL 時，會在系統中新增 mysql 的使用者與群組，並用這組權限來控制資料庫。但是在 /etc/my.cnf 中指定的路徑權限屬於 root:root，在無法讀取 log 檔案的情況下，MySQL 就無法正常打開。二、error_log 設定方式1. 先新增 MySQL 的 log 檔案$ touch /var/log/mysql/error.log2. 將 /var/log/mysql 及其下資料夾和檔案的權限設定為 mysql:mysql$ chown -R mysql:mysql /var/log/mysql3. 設定 /etc/mysqlvim /etc/my.cnf[mysqld]log_error=/var/log/mysql/error.log4. 重新啟動 mysql$ lnmp restart mysql5. 確認設定成功error_log 設定完成後，可以看看 log 第一行有沒有啟動訊息。2022-12-15T09:53:24.789020Z 0 [System] [MY-010116] [Server] /usr/local/mysql/bin/mysqld (mysqld 8.0.13) starting as process 21119參考資料 LNMP 設定 MySQL 的錯誤日誌" }, { "title": "將 Jitsi meet 架設在 Azure 雲端上", "url": "/posts/2023-01-10-Setup-Jitsi-Meet-Server-on-Azure-30/", "categories": "Ubuntu, Azure", "tags": "ubuntu, nginx, jitsi", "date": "2023-01-10 00:00:00 +0800", "snippet": "使用的環境 系統與使用工具 Ubuntu-20.04 nginx/1.18.0 openjdk 11.0.17 嗨。一、Jitsi Meet 介紹1. Jitsi Meet 是什麼？Jitsi 是免費且開源的視訊會議程式，支援多種語言，使用網頁就可以操作所有功能，無須安裝任何東西。自行架設的話則包含 server 和 client 端，client 端包含了網頁瀏覽器、手機 app 等介面。2. 誰適合使用？適合不想付費、註冊會員、下載或安裝軟體，或是想要長時間開啟視訊會議的人。二、Azure 建立新機器資訊 項目 設定資訊 作業系統 Ubuntu 20.04 規格 Standard B2s (2 vcpu，4 GiB 記憶體) 資源群組 jitsi 電腦名稱 美國東部2 East US 2 DNS名稱標籤 80,443,10000,22,3478,5349 SSH登入指令 ssh username@jitsi.eastus2.cloudapp.azure.com 三、Azure 開新機器及圖片介紹 建立資源，選擇 Ubuntu Server 20.04 tls。 自訂資源群組名稱、機器名稱，並選擇區域。 選擇機器大小，設定登入金鑰或密碼，對外 port 勾選 [80,443,22]，再按下左下角的檢閱+建立，建立新機器。 在網路新增 Jitst 所需的 port[80,443,10000,22,3478,5349]，並命名為port_jitsi，前面已經設定過 80,443,22 了，現在又再設定一次是為了集中管理 Jitsi 所需的 port，實際上不影響。 再組態設定 DNS 名稱標籤。 設定皆完成，可以開始連線至機器囉。 四、SSH 連線至機器$ ssh username@jitsi.eastus2.cloudapp.azure.com五、安裝 Jitsi 所需要的工具1. 需要的工具 gnupg2 nginx-full sudo =&amp;gt; Only needed if you use sudo curl =&amp;gt; Or wget to Add the Jitsi package repository OpenJDK 11 must be used.2. 把需要的工具安裝起來$ sudo -s $ apt update -y$ apt install -y apt-transport-https$ apt-add-repository universe # jisti需要$ apt install -y gnupg2$ apt install -y nginx$ apt install -y openjdk-11-jdk# sudo 跟 curl 原本就有所以沒裝3. 檢查是否有安裝完成$ nginx -V$ java --version$ sudo -V$ curl -V六、 編輯 /etc/hosts$ vim /etc/hostsx.x.x.x myjitsi.test123.com myjitsi# x.x.x.x 是本機IP，myjitsi.test123.com 是自訂的域名，後面的 myjitsi 是電腦名稱# 重開機吃設定$ reboot 七、 Add the Prosody package repository$ echo deb http://packages.prosody.im/debian $(lsb_release -sc) main | sudo tee -a /etc/apt/sources.list$ wget https://prosody.im/files/prosody-debian-packages.key -O- | sudo apt-key add -$ apt install lua5.2八、 Add the Jitsi package repository$ curl https://download.jitsi.org/jitsi-key.gpg.key | sudo sh -c &#39;gpg --dearmor &amp;gt; /usr/share/keyrings/jitsi-keyring.gpg&#39;$ echo &#39;deb [signed-by=/usr/share/keyrings/jitsi-keyring.gpg] https://download.jitsi.org stable/&#39; | sudo tee /etc/apt/sources.list.d/jitsi-stable.list &amp;gt; /dev/null$ apt update九、 設定防火牆$ ufw allow 80/tcp$ ufw allow 443/tcp$ ufw allow 10000/udp$ ufw allow 22/tcp$ ufw allow 3478/udp$ ufw allow 5349/tcp$ ufw enable # 啟動 ufw$ ufw status verbose # 查看 ufw 狀態十、 安裝 jitsi$ apt install -y jitsi-meet安裝過程會詢問的問題： 域名要哪個？—— myjitsi.test123.com SSl 憑證要用哪個？—— Let’s Encrypt Certificate 輸入Email(SSL用)—— username@gmail.com Add telephony to your Jitsi meetings?—— no十一、 在瀏覽器輸入網址myjitsi.test123.com進入網站後即可開始使用基本的 Jitsi。大功告成！參考資料 jitsi Self-Hosting Guide - Debian/Ubuntu server How To Install Jitsi Own Server For Video Conference On Ubuntu 20.04 Jitsi Meet 視訊會議教學：免費無限時間、共享桌面、會議錄影" }, { "title": "Nginx 限制請求的速度", "url": "/posts/2022-12-20-Nginx-http-limit-req-module-29/", "categories": "Nginx", "tags": "nginx, limit, module", "date": "2022-12-20 00:00:00 +0800", "snippet": "使用的環境 系統與使用工具 Centos 7.6 nginx/1.16.1 Naxsi 1.3 一、ngx_http_limit_req_module 寫法介紹# 保存 10MB 的 ip 的 request 紀錄，每分鐘可以接受 100 個 request。limit_req_zone $binary_remote_addr zone=mylimit:10m rate=100r/m; $binary_remote_addr 指的是 client 端的 IP，根據 client 端的 IP 進行限流。 zone=mylimit:10m limiter(zone) 叫做 mylimit，並且最多可以使用 10MB 的儲存空間來儲存每個 IP 的請求次數（10MB 可以存十幾萬個 IP）。 rate=100r/m 每分鐘一百個請求。但要注意的是 nginx 會幫你換算成多少毫秒可以接受一個新請求，譬如說每分鐘一百個，就會幫你換算成 600 毫秒一個請求，因此如果你在 600 毫秒內同時發了十個請求，那就只有第一個會被接受，其他九個都會直接被拒絕掉。 二、Nginx.conf 設定 如果要真實 IP 可以把 $binary_remote_addr換成$http_x_forwarded_for，除了remote_addr，HTTP_CLIENT_IP和http_x_forwarded_for可以被偽造。remote_addr雖然可以取得安全可靠的 IP，但無法確定它是否為使用者真正的IP。http { limit_req_zone $binary_remote_addr zone=mylimit:1m rate=2r/s; }三、Vhost.conf 設定去網址的 conf 檔設定，可設定 location 路徑再套用限速規則。location /login { limit_req zone=mylimit; }四、 reload Nginx$ nginx -s reload五、查看是否有設定成功去網站狂按 F5，看會不會出現 503，意思是「流量過大或正在維修」，有的話即為設定成功。503 Service Temporarily Unavailable 六、額外：也可以一次宣告多個 zone# 也可以一次宣告多個 zonehttp { limit_req_zone $binary_remote_addr zone=limit_verifyPhone:10m rate=2r/m; limit_req_zone $binary_remote_addr zone=limit_resetPassword:10m rate=1r/m; server { # 也可以套用在 POST 請求上 location /api/verifyPhone { limit_req zone=limit_verifyPhone; proxy_pass http://backend; } location /api/resetPassword { limit_req zone=limit_resetPassword; proxy_pass http://backend; } }}參考資料 Module ngx_http_limit_req_module [Web] Nginx limit_req 指南 – ngx_http_limit_req_module NGINX Rate Limiting: 使用limit_req_zone來限制request量 Day09-流量限制（四）" }, { "title": "閱讀心得(4)：強大內心的自我對話習慣", "url": "/posts/Book-review-4-28/", "categories": "Review", "tags": "book, review", "date": "2022-11-29 00:00:00 +0800", "snippet": "書名：強大內心的自我對話習慣 作者：伊森．克洛斯譯者：胡宗香出版社：天下雜誌股份有限公司出版日期：2021/05/26閱讀心得：　　這本書提到我們的思緒會出現「內在聲音」、「小對話」，「內在聲音」是人腦中跟自己私下對話的聲音，形式和表現因人而異；而「小對話」是負面想法和情緒構成的循環，會危及我們的表現、決策能力、人際關係、快樂與健康。　　小對話發生時，我們會感覺到被心智折磨，讓我們的思想及行為癱瘓，甚至做出傷害自己的事情。　　為了不被負面情緒綁架，本書也提供一些方式解決，包括自己可以實踐的對抗工具、依靠他人協助的對抗工具，或者周遭環境中的對抗工具。在這邊就不全部都列出，只列出我最喜歡的幾個： 使用抽離式自我對話：使用自己的名字或是第二人稱「你」來稱呼自己，這樣可以讓大腦不停回想事件的活躍度降低，提升壓力下的表現，讓思考更明智，減少負面情緒。 以書寫表達：每天花費十五分鐘寫下有關負面經驗最深刻的想法與感受，從敘事者觀點看待自己的經驗，拉開與這個經驗的距離，有助於釐清自己的感受。 投入引發敬畏感的體驗：升起敬畏感，能讓我們超越當下的憂慮，把自己的問題放在更大的格局中觀察，可以是看到壯麗景觀，也可以是凝視一件出色的藝術品。找出能讓人充滿敬畏感的事物，就會感到自己的渺小，而你的問題根本微不足道。 　　這本書提供了很多有效且令我想實踐的方式，但是內文偏少，而參考資料佔了整本書的四分之一，在看完正文時，整個人霧煞煞，想說為什麼還這麼多頁，不過這也代表作者在撰寫這本書時，參考及引用了大量的學術文章，讓我們知道這些理論或方式不是憑空出現的。" }, { "title": "哇虎！使用 Nginx 的 Naxsi 模組實現 WAF 功能", "url": "/posts/2022-10-13-Nginx-Naxsi-module-27/", "categories": "Nginx", "tags": "nginx, naxsi, module", "date": "2022-10-13 00:00:00 +0800", "snippet": "使用的環境 系統與使用工具 Centos 7.6 nginx/1.16.1 Naxsi 1.3 一、WAF 介紹WAF（Web Application Firewall，網站應用程式防火牆），主要為保護網站應用程式，透過監控及過濾 HTTP/HTTPS 請求來分析網路行為，拒絕可疑、惡意流量進入網站，只讓安全且正常的流量通過。只能即時保護應用程式，不能修復漏洞，但在防禦的同時，可以有緩衝時間修復應用程式的漏洞。方式：依據事先設計好的安全政策，發掘違反安全政策的封包。目的：保護 web 應用程式，防禦 XSS 及 SQL injection 等攻擊。 支持 POST/GET 位於網頁瀏覽者與網頁伺服器中間，專責分析與過濾 「Layer7 應用層」 的網路流量 有些更強大的甚至可以掃描惡意木馬文件、防竄改、伺服器優化、備份 如果網站有蒐集 cookie、用戶資料、表單紀錄，建議使用 WAF （圖片來源：cloudmax 部落格）二、WAF 優缺點 優點 缺點 1. 開箱即用 1. 誤殺、漏報 2. 管理方便，介面友好 2. 只適合中小型網站 3. 功能豐富 3. 必須客製化規則才能有效的抵擋攻擊   4. 功能強大的 WAF 很貴 三、Naxsi 模組介紹Naxsi 是 Nginx 的第三方模組，與任何 Nginx 版本都相容，採用 GPLv3 授權，可以免費使用，也不需要依賴類似防毒軟體的病毒碼資料庫。可以建置簡易的 WAF 系統，阻擋一些常見的 Nginx Anti XSS 及 SQL Injection 攻擊，但只能過濾「GET」及「POST」的請求。四、Naxsi 的規則檔 naxsi_core.rules舉例 naxsi_core.rules 內的部份規則：#################################### SQL Injections IDs:1000-1099 ####################################MainRule &quot;rx:select|union|update|delete|insert|table|from|ascii|hex|unhex|drop|load_file|substr|group_concat|dumpfile&quot; &quot;msg:sql keywords&quot; &quot;mz:BODY|URL|ARGS|$HEADERS_VAR:Cookie&quot; &quot;s:$SQL:4&quot; id:1000;MainRule &quot;str:\\&quot;&quot; &quot;msg:double quote&quot; &quot;mz:BODY|URL|ARGS|$HEADERS_VAR:Cookie&quot; &quot;s:$SQL:8,$XSS:8&quot; id:1001;MainRule &quot;str:0x&quot; &quot;msg:0x, possible hex encoding&quot; &quot;mz:BODY|URL|ARGS|$HEADERS_VAR:Cookie&quot; &quot;s:$SQL:2&quot; id:1002;## Hardcore rulesMainRule &quot;str:/*&quot; &quot;msg:mysql comment (/*)&quot; &quot;mz:BODY|URL|ARGS|$HEADERS_VAR:Cookie&quot; &quot;s:$SQL:8&quot; id:1003;MainRule &quot;str:*/&quot; &quot;msg:mysql comment (*/)&quot; &quot;mz:BODY|URL|ARGS|$HEADERS_VAR:Cookie&quot; &quot;s:$SQL:8&quot; id:1004;MainRule &quot;str:|&quot; &quot;msg:mysql keyword (|)&quot; &quot;mz:BODY|URL|ARGS|$HEADERS_VAR:Cookie&quot; &quot;s:$SQL:8&quot; id:1005;MainRule &quot;str:&amp;amp;&amp;amp;&quot; &quot;msg:mysql keyword (&amp;amp;&amp;amp;)&quot; &quot;mz:BODY|URL|ARGS|$HEADERS_VAR:Cookie&quot; &quot;s:$SQL:8&quot; id:1006;## end of hardcore rulesMainRule &quot;str:--&quot; &quot;msg:mysql comment (--)&quot; &quot;mz:BODY|URL|ARGS|$HEADERS_VAR:Cookie&quot; &quot;s:$SQL:4&quot; id:1007;MainRule &quot;str:;&quot; &quot;msg:semicolon&quot; &quot;mz:BODY|URL|ARGS&quot; &quot;s:$SQL:4,$XSS:8&quot; id:1008;MainRule &quot;str:=&quot; &quot;msg:equal sign in var, probable sql/xss&quot; &quot;mz:ARGS|BODY&quot; &quot;s:$SQL:2&quot; id:1009;MainRule &quot;str:(&quot; &quot;msg:open parenthesis, probable sql/xss&quot; &quot;mz:ARGS|URL|BODY|$HEADERS_VAR:Cookie&quot; &quot;s:$SQL:4,$XSS:8&quot; id:1010;MainRule &quot;str:)&quot; &quot;msg:close parenthesis, probable sql/xss&quot; &quot;mz:ARGS|URL|BODY|$HEADERS_VAR:Cookie&quot; &quot;s:$SQL:4,$XSS:8&quot; id:1011;MainRule &quot;str:&#39;&quot; &quot;msg:simple quote&quot; &quot;mz:ARGS|BODY|URL|$HEADERS_VAR:Cookie&quot; &quot;s:$SQL:4,$XSS:8&quot; id:1013;MainRule &quot;str:,&quot; &quot;msg:comma&quot; &quot;mz:BODY|URL|ARGS|$HEADERS_VAR:Cookie&quot; &quot;s:$SQL:4&quot; id:1015;MainRule &quot;str:#&quot; &quot;msg:mysql comment (#)&quot; &quot;mz:BODY|URL|ARGS|$HEADERS_VAR:Cookie&quot; &quot;s:$SQL:4&quot; id:1016;MainRule &quot;str:@@&quot; &quot;msg:double arobase (@@)&quot; &quot;mz:BODY|URL|ARGS|$HEADERS_VAR:Cookie&quot; &quot;s:$SQL:4&quot; id:1017;五、Naxsi 規則與攔截分數介紹1. 規則解說與計分方式 這是 naxsi_core.rules 內的部份規則。 規則 規則解說 id 為 1001 的規則 MainRule &quot;str:\\&quot;&quot; &quot;msg:double quote&quot; &quot;mz:BODY|URL|ARGS|$HEADERS_VAR:Cookie&quot; &quot;s:$SQL:8,$XSS:8&quot; id:1001; 表示如果在請求體(BODY)，統一資源定位符(URL)，請求參數(ARGS)，請求標題(Cookie)任何地方出現了雙引號(“)，就表示該請求可能是 SQL 注入或是 XSS 攻擊，判斷分數皆為 8。 id 為 1002 的規則表示 MainRule &quot;str:0x&quot; &quot;msg:0x, possible hex encoding&quot; &quot;mz:BODY|URL|ARGS|$HEADERS_VAR:Cookie&quot; &quot;s:$SQL:2&quot; id:1002; 表示如果在請求體(BODY)，統一資源定位符(URL)，請求參數(ARGS)，請求標題(Cookie)任何地方出現了雙引號(“)，就表示該請求可能是 SQL 注入或是 XSS 攻擊，判斷分數皆為 2。 id 為 1013 的規則表示 MainRule &quot;str:&#39;&quot; &quot;msg:simple quote&quot; &quot;mz:ARGS|BODY|URL|$HEADERS_VAR:Cookie&quot; &quot;s:$SQL:4,$XSS:8&quot; id:1013; 表示如果在請求體(BODY)，統一資源定位符(URL)，請求參數(ARGS)，請求標題(Cookie)任何地方出現了單引號(‘)，就表示該請求可能是 SQL 注入或是 XSS 攻擊，判斷分數為 4 跟 8。 2. 攔截分數（建立網站防護規則） 這是在 nginx.conf 內的設定，最終分數可以自訂，一旦累積的分數到達設定的標準，就會攔截並回報錯誤，詳細設定方式底下介紹。# 設定 Naxsi 何時行動，可自行調整阻擋的分數，當請求達到此分數時，請求將被拒絕# 以下設定為當分數累積到到 8 (或 4)後就阻擋CheckRule &quot;$SQL &amp;gt;= 8&quot; BLOCK; CheckRule &quot;$RFI &amp;gt;= 8&quot; BLOCK;CheckRule &quot;$TRAVERSAL &amp;gt;= 4&quot; BLOCK;CheckRule &quot;$UPLOAD &amp;gt;= 4&quot; BLOCK;CheckRule &quot;$XSS &amp;gt;= 8&quot; BLOCK;六、安裝 Naxsi 模組1. 安裝必要套件$ yum groupinstall &quot;development tools&quot; -y2. 安裝 PCRE 以及 openssl 套件$ yum install pcre pcre-devel openssl openssl-devel -y3. 在想要的路徑下載 Naxsi我是安裝在 /usr/local/nginx_module 內。$ git clone https://github.com/nbs-system/naxsi.git4. 路徑整理從 Github 下載的 Naxsi 位置/usr/local/naxsinaxsi主要資料夾/usr/local/naxsi/naxsi_srcnaxsi 規則檔/usr/local/naxsi/naxsi_config/naxsi_core.rules5. 編譯 Nginx要在有 configure 的那個資料夾底下編譯，模組安裝路徑可以用絕對路徑比較保險，使用 --add-dynamic-module 把 Naxsi 加進去。$ ./configure --user=www --group=www \\ --prefix=/usr/local/nginx \\ --with-http_stub_status_module \\ --with-http_ssl_module \\ --with-http_v2_module \\ --with-http_gzip_static_module \\ --with-http_sub_module \\ --with-stream \\ --with-stream_ssl_module \\ --with-openssl=/root/lnmp1.6/src/openssl-1.1.1d \\ --with-openssl-opt=enable-weak-ssl-ciphers \\ --add-dynamic-module=/usr/local/nginx_module/ngx_http_geoip2_module \\ --add-dynamic-module=/usr/local/nginx_module/naxsi/naxsi_src$ make # 有些人說不要 make install，但我用 make module 或純粹 make 都沒有用，不知道原因$ make install編譯成功後長這樣：$ nginx -Vnginx version: nginx/1.16.1built by gcc 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC)built with OpenSSL 1.1.1d 10 Sep 2019TLS SNI support enabledconfigure arguments: --user=www --group=www --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-http_v2_module --with-http_gzip_static_module --with-http_sub_module --with-stream --with-stream_ssl_module --with-openssl=/root/lnmp1.6/src/openssl-1.1.1d --with-openssl-opt=enable-weak-ssl-ciphers --add-dynamic-module=/usr/local/nginx_module/ngx_http_geoip2_module --add-dynamic-module=/usr/local/nginx_module/naxsi/naxsi_src6. 將 Naxsi 主要設定檔複製進 Nginx 資料夾中$ cp /usr/local/nginx_module/naxsi/naxsi_config/naxsi_core.rules /usr/local/nginx/conf7. 新增一個 Naxsi 規則檔案這是上面攔截分數把他包成一個檔案 naxsi_custom.rules，到時候再 include 到 nginx.conf 裡面。 底下設定在上面第 2 節有介紹。$ vim /usr/local/nginx/conf/naxsi_custom.rules# 開啟 naxsiSecRulesEnabled;# 學習模式 預設關閉#LearningMode; # 透過 libinjection 判斷 SQL 注入和 XSS 攻擊LibInjectionSql;LibInjectionXss;# 拒絕訪問時展示的頁面 DeniedUrl &quot;/RequestDenied&quot;; # 設定 Naxsi 何時行動，可自行調整阻擋的分數，當請求達到此分數時，請求將被拒絕# 以下設定為當分數累積到到 8 (或 4)後就阻擋CheckRule &quot;$SQL &amp;gt;= 8&quot; BLOCK; CheckRule &quot;$RFI &amp;gt;= 8&quot; BLOCK;CheckRule &quot;$TRAVERSAL &amp;gt;= 4&quot; BLOCK;CheckRule &quot;$UPLOAD &amp;gt;= 4&quot; BLOCK;CheckRule &quot;$XSS &amp;gt;= 8&quot; BLOCK;# Naxsi 的 log 位置設定error_log /home/wwwlogs/naxsi_attach.log;8. 開始設定(1) nginx.conf$ vim /usr/local/nginx/conf/nginx.conf裡面設定：# 在全區塊 pid 下面新增這句：load_module modules/ngx_http_naxsi_module.so;# 在 http include ruleshttp { include /usr/local/nginx/conf/naxsi_core.rules; }# 在 server include rulesserver { location / { include /usr/local/nginx/conf/naxsi_custom.rules; } location /RequestDenied # 要搭配上面的 DeniedUrl &quot;/RequestDenied&quot;; { return 400; # 被阻擋後顯示錯誤 400 } }(2) vhost.conf$ vim /usr/local/nginx/conf/vhost/xxx.conf裡面設定：server { location / { include /usr/local/nginx/conf/naxsi_custom.rules; } location /RequestDenied # 要搭配上面的 DeniedUrl &quot;/RequestDenied&quot;; { return 400; # 被阻擋後顯示錯誤 400 } }9. 重新啟動或重新讀取 Nginx# 重新啟動 nginx$ nginx -s reopen# 重新讀取 nginx$ nginx -s reload七、實際測試1. 瀏覽器上測試在有設定 Naxsi 的網站上面打這些 SQL 注入的請求：http://url/=&amp;lt;&amp;gt;http://url/?a=&amp;lt;&amp;gt;http://localhost/?...&amp;lt;&amp;gt;http://localhost/?id=&amp;lt;&amp;gt;2. 主機上測試在終端機上面存取有設定 Naxsi 的網站：$ curl -IL &quot;http://x.x.x.x/?a=&amp;lt;&amp;gt;&quot;$ wget &quot;https://xxx.xxx.com/?&amp;lt;&amp;gt;&quot;八、攔截成功畫面與分析1. 當下攔截畫面觀察網站收到 SQL 注入的請求後有沒有報400。2. 攔截 log 查看3. log 分析查看設定的 naxsi_attach.log，若在 log 中出現 NAXSI_FMT 開頭，就是啟用成功。 挑 2022/10/20 17:53:37 那行 log 來當範例（IP 跟網址有改過）。2022/10/20 17:53:37 [error] 7275#0: *5428 NAXSI_FMT: ip=223.58.42.103&amp;amp;server=taipei.test.com&amp;amp;uri=/=a&amp;lt;&amp;gt;&amp;amp;vers=1.3&amp;amp;total_processed=20&amp;amp;total_blocked=3&amp;amp;config=block&amp;amp;cscore0=$XSS&amp;amp;score0=8&amp;amp;zone0=URL&amp;amp;id0=1302&amp;amp;var_name0=, client: 223.58.42.103, server: taipei.test.com, request: &quot;GET /=a%3C%3E HTTP/2.0&quot;, host: &quot;taipei.test.com&quot;且對應到的規則是以下兩行：########################################## Cross Site Scripting IDs:1300-1399 ##########################################MainRule &quot;str:&amp;lt;&quot; &quot;msg:html open tag&quot; &quot;mz:ARGS|URL|BODY|$HEADERS_VAR:Cookie&quot; &quot;s:$XSS:8&quot; id:1302; log log 分析 NAXSI_FMT 2022/10/20 17:53:37 [error] 7275#0: *5428 NAXSI_FMT: 對方IP ip=223.58.42.103&amp;amp; 請求的主機名　 server=taipei.test.com&amp;amp; uri uri=/=a&amp;lt;&amp;gt;&amp;amp; Naxsi 版本　 vers=1.3&amp;amp; 總共請求 20 次　 total_processed=20&amp;amp; 總共阻擋 3 次　 total_blocked=3&amp;amp; 設定：攔截　 config=block&amp;amp; 分數標籤：XSS　 cscore1=$XSS&amp;amp; XSS分數 score1=8&amp;amp; 符合的區域　 zone0=URL&amp;amp; 符合的規則 id　 id0=1302&amp;amp; 符合的變數 var_name0= , 對方 IP client: 223.58.42.103,   server=taipei.test.com, 請求內容 request: “GET /=a%3C%3E HTTP/2.0”,   host: “taipei.test.com” 九、(額外)開啟 NAXSI_EXLOG開啟 NAXSI_EXLOG，可以記錄具體觸發 Naxsi 攔截規則的請求內容，內容紀錄正常和異常的請求，方便後續分析攔截的是攻擊請求還是誤判。 log log 分析 NAXSI_FMT（原本就有） 僅包含 ID 和異常的位置 NAXSI_EXLOG 提供了實際的內容，可以輕鬆確認它是否為誤報 1. NAXSI_EXLOG 設定在 conf 檔裡的 server 部分新增設定：$ vim /usr/local/nginx/conf/vhost/xxx.conf$ vim /usr/local/nginx/conf/nginx.conf裡面設定：server { set $naxsi_extensive_log 1; }2. NAXSI_EXLOG 的 log 畫面會多出現一個 NAXSI_EXLOG，就表示開啟成功。十、(額外)將 Naxsi 加入 Fail2ban1. Fail2ban 新增 Naxsi 過濾器filter 的 conf 名稱可以自訂。$ vim /etc/fail2ban/filter.d/nginx-naxsi.conf[INCLUDES]before = common.conf[Definition]failregex = NAXSI_FMT: ip=&amp;lt;HOST&amp;gt;&amp;amp;server=.*&amp;amp;uri=.*&amp;amp;learning=0 NAXSI_FMT: ip=&amp;lt;HOST&amp;gt;.*&amp;amp;config=blockignoreregex = NAXSI_FMT: ip=&amp;lt;HOST&amp;gt;.*&amp;amp;config=learning2. Fail2ban 主要設定檔設定$ vim /etc/fail2ban/jail.local[nginx-naxsi]enabled = truefilter = nginx-naxsiaction = iptables-multiport[name=nginx-naxsi, port=&quot;http,https&quot;, protocol=tcp]logpath = /home/wwwlogs/naxsi_attach.logmaxretry = 6bantime = -1 # 封鎖一輩子！十一、(額外)白名單Naxsi 社區提供一些常用的白名單規則，例如:wordpress。naxsi-rules Github然後將規則 include 到 server 內的 location，重啟 nginx 即可，不過要注意一些這些白名單的修改日期，有些太老。參考資料 Naxsi Github WAF 是什麼？你的網站需要 WAF 嗎？ naxsi-rules Github Naxsi 配置白名單 Nginx 搭配 Naxsi 實現 WAF 功能 Nginx naxsi + 色情守門員 Install and Configure Nginx With Naxsi NAXSI安裝測試與簡介 沒 WAF 防火牆還想混網路？ WAF 防火牆非裝不可的 3 個原因" }, { "title": "閱讀心得(3)：在意別人而受傷，怎麼找回快樂", "url": "/posts/Book-review-3-26/", "categories": "Review", "tags": "book, review", "date": "2022-08-22 00:00:00 +0800", "snippet": "書名：在意別人而受傷，怎麼找回快樂作者：李東龜博士、李誠職博士、安夏陽博士出版社：方言文化出版日期：2021/11/10閱讀心得：　　起初看到書名跟簡介就覺得很適合時常在意別人眼光的我，原因主要來自家庭影響及對身材的不自信，但是隨著年紀增長就越想要活出自己的風格，不想被別人的眼光及話語給束縛住。這本書詳細說明過度在意的類型與狀況，也提出一些建議作為改變自己的參考。　　書中說認同需求是期待自己的信念或行動希望自己的存在被肯定，也與馬斯洛提出的「需求層次理論」相同，但當認同需求過度，就等於將自己交給他人，若過度投入在這種思維，正常的自己就會消失，成為了他人眼中的自已，徒留孤單。　　有幾種解決方式，譬如：信賴自己的看法、感受跟判斷、藉由細微的小事提升自我人生的滿足感，或者是在難以擺脫痛苦、不安之時，找尋可安慰、撫慰自己的話語或行為，可以是別人說過的話或是勵志書籍上的一段話，下次若又遇到這種情況，就可以快速給自己勇氣跳出當下的情緒迴圈，也可試著選擇不同過往的自己所選擇的方式。　　從現在開始關注自己，傾聽自己內心那充滿陽光的聲音，並且開始規劃「有意義和有目標的生活」。分享書裡很喜歡的一段句子：「他人是否認同自己，不是我們可以控制的，我們能夠調整和控制的只有接納自我這件事情」。" }, { "title": "利用 Nginx 的 GeoIP2 模組限制特定國家 IP 造訪網站", "url": "/posts/2022-08-11-Nginx-Geoip2-module-25/", "categories": "Nginx", "tags": "nginx, geoip2, geolite2, module", "date": "2022-08-11 00:00:00 +0800", "snippet": "使用的環境 系統與使用工具 Centos 7.6 nginx/1.16.1 geoipupdate 2.5.0 一、Nginx GeoIP2 模組介紹GeoIP2 是 Nginx 的動態模組，搭配 MaxMind 資料庫，可自動辨識 IP 所位於的國家，並設定規則，當特定國家 IP 造訪網站時，做出自訂的回應方式。二、下載 GeoIP2 模組的兩個方式1. GetPageSpeed 的 RPM repo（需訂閱付費） 這要付錢，純紀錄，本篇文章不用這個方式。先去下載 GetPageSpeed 的 RPM repo，這樣才能載到新版的 nginx-module-geoip2。$ yum -y install https://extras.getpagespeed.com/release-latest.rpm$ yum install nginx-module-geoip2安裝到一半會說”缺少訂閱所以停止”，並附上一個訂閱的網址，點進去看到自己的 IP，再按訂閱就會跳至付款畫面。如果安裝了這個 repo，但反悔想刪掉的話怎麼辦？# 先查詢這個 repo 完整的 rpm 套件名稱$ rpm -qa |grep -i getpagespeedgetpagespeed-extras-release-11-31.noarch# 如果有找到 rpm 套件名稱，就可加上 -e 刪除$ rpm -e getpagespeed-extras-release-11-31.noarch2. 從 Github 下載leev/ngx_http_geoip2_module# 建立新資料夾$ mkdir nginx_module/$ cd nginx_module/# 下載 Github 上的 GeoIP2 模組$ git clone https://github.com/leev/ngx_http_geoip2_module.git$ cd ngx_http_geoip2_module/三、安裝 geoipupdate因為 IP 時常有變化，所以 MaxMind 提供 geoipupdate 工具，可以讓我們更新 IP 清單，但這個工具需要搭配 MaxMind 帳號和 License Key。$ yum install geoipupdate geoipupdate-cron -y# 查看版本$ geoipupdate -vgeoipupdate 2.5.0查看版本是因為 License Key 需要對應 geoipupdate 的版本。也可以從 MaxMind 官方 Github 下載新版的 geoipupdatemaxmind/geoipupdate目前最新的版本是 4.9.0 (2022/08)。# 下載 geoipupdate 的 RPM 套件$ wget https://github.com/maxmind/geoipupdate/releases/download/v4.9.0/geoipupdate_4.9.0_linux_386.rpm# 安裝 geoipupdate $ rpm -i geoipupdate_4.8.0_linux_386.rpm四、取得免費的 GeoLite2 的 License KeyMaxMind 提供的資料庫有分為商業版 GeoIP2 和免費版 GeoLite2，免費版的資料庫有各國家的 IP 對照表，而商業版有城市、經緯度等等更詳細的資訊。網路上有網友實測，免費版的對於城市定位精準度會有些差異，所以就看看自己的需求來選擇囉～本篇文章是使用 GeoLite2 資料庫。1. 註冊會員GeoLite2填寫完再去 mail 啟用和設定密碼後就代表註冊成功了！2. 建立 License Key登入 MaxMind 網站後，按左方 Manage License Keys，現在來要建立 License Key。依照 geoipupdate 版本去選（我的 geoipupdate 版本是 2.5.0）。之後會有 ID 跟 License Key，點選 Download Config，會自動下載一個 GeoIP.conf 檔案，將這個檔案覆蓋主機上的 /etc/GeoIP.conf。3. 更新 Maxmind 資料庫覆蓋完 GeoIP.conf 檔案後，用 geoipupdate 跑一次 Maxmind 資料庫更新。$ geoipupdate$ geoipupdate -v可以將指令寫進 crontab 排程，讓它定時更新 Maxmind 資料庫。1 0 * * 1,4 /usr/bin/geoipupdate小技巧：mmdblookup 工具mmdblookup 可以在指定的 Maxmind 資料庫中查詢 IP，IP 的記錄會以類似 JSON 的結構顯示。Maxmind 資料庫檔案放在 /usr/share/GeoIP。國家清單可以參考此網站# -f/--file: 指定檔案# -i/--ip: 指定 IP# -v: 詳細說明# country names 表示是用什麼語言來輸出國家名稱$ mmdblookup --file /usr/share/GeoIP/GeoLite2-Country.mmdb --ip 47.52.76.54 country names en$ mmdblookup --file /usr/share/GeoIP/GeoLite2-Country.mmdb --ip 47.52.76.54 country iso_code五、Nginx 編譯 GeoIP 模組1. 找到有含 configure 的資料夾若 Nginx 是用 yum install 安裝的，會沒有 configure 檔案，但如果真的想要新增第三方模組，只需對相同版本的 Nginx 原始碼進行編譯後替換即可。 但模組若也是用 yum install 安裝，就可以直接在 nginx.conf 上面新增 load_module modules/ngx_http_geoip2_module.so;我的 Nginx 是 1.16.1 版本，就找 Nginx 1.16.1 的壓縮檔 nginx-1.16.1.tar.gz，並解壓縮，就可以得到 configure 以及其他編譯需要用的檔案。$ tar xvpzf nginx-1.16.1.tar.gz$ cd nginx-1.16.1$ ll2. 查看 Nginx 原先有的模組先查看 Nginx 原本有什麼模組，當編譯新的模組時，原有的模組也要原封不動的寫進去，不然到時候編譯完成後會不見（就是底下 configure arguments 那段）。$ nginx -Vnginx version: nginx/1.16.1built by gcc 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC)built with OpenSSL 1.1.1d 10 Sep 2019TLS SNI support enabledconfigure arguments: --user=www --group=www --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-http_v2_module --with-http_gzip_static_module --with-http_sub_module --with-stream --with-stream_ssl_module --with-openssl=/root/lnmp1.6/src/openssl-1.1.1d --with-openssl-opt=enable-weak-ssl-ciphers3. 編譯 GeoIP2 模組要在有 configure 的那個資料夾底下編譯，模組安裝路徑可以用絕對路徑比較保險。$ ./configure --user=www --group=www \\--prefix=/usr/local/nginx \\--with-http_stub_status_module \\--with-http_ssl_module \\--with-http_v2_module \\--with-http_gzip_static_module \\--with-http_sub_module \\--with-stream \\--with-stream_ssl_module \\--with-openssl=/root/lnmp1.6/src/openssl-1.1.1d \\--with-openssl-opt=enable-weak-ssl-ciphers \\--add-dynamic-module=/usr/local/nginx_module/ngx_http_geoip2_module$ make # 有些人說不要 make install，但我用 make module 或純粹 make 都沒有用，不知道原因$ make install4. 編譯時出現問題error:adding module in /usr/local/nginx_module/ngx_http_geoip2_modulechecking for MaxmindDB library ... not found./configure: error: the geoip2 module requires the maxminddb library.上網爬文，安裝 libmaxminddb-devel 後即可正常編譯。$ yum install libmaxminddb-devel安裝好後，重複上面第 3 點的步驟。5. 查看是否編譯成功$ nignx -V在 Nginx 的安裝路徑也會自動產生一個 modules 資料夾，且裡面有兩個檔案，有出現代表新增模組成功。/usr/local/nginx/modules/ngx_http_geoip2_module.so/usr/local/nginx/modules/ngx_stream_geoip2_module.so六、Nginx.conf 或 vhost.conf 設定開始設定 nginx.conf。$ vim /usr/local/nginx/conf/nginx.conf1. 全區塊在 pid 下面新增這兩句：load_module modules/ngx_http_geoip2_module.so;load_module modules/ngx_stream_geoip2_module.so;2. http 區塊在 http 區塊新增下面這串:geoip2 /usr/share/GeoIP/GeoLite2-Country.mmdb {auto_reload 5m;$geoip2_metadata_country_build metadata build_epoch;$geoip2_data_country_code country iso_code;$geoip2_data_country_name country names en;}geoip2 /usr/share/GeoIP/GeoLite2-City.mmdb {$geoip2_data_city_name city names en;}fastcgi_param COUNTRY_CODE $geoip2_data_country_code;fastcgi_param COUNTRY_NAME $geoip2_data_country_name;fastcgi_param CITY_NAME $geoip2_data_city_name;map $geoip2_data_country_code $blacklisted_country {default no;CN yes; #yes 就是封鎖HK yes; #yes 就是封鎖} server 區塊在 server 區塊新增下面這串:if ($blacklisted_country = yes) { return 400; }七、測試是否成功上面在 nginx.conf 的 http 區塊有設定 CN yes; 和 HK yes;，代表：當造訪的 IP 是來自於 CN 跟 HK，就會收到 400 錯誤。CN yes; #yes 就是封鎖HK yes; #yes 就是封鎖可以利用 curl 工具來測試這個模組及設定有沒有運作。# -I: 顯示 Header# -L: 是跟著301走（會轉址）$ curl -IL xxxxx.com$ curl -IL x.x.x.x實際測試本篇文章使用的主機是來自 HK ，因此可以試著自己造訪自己，看看結果如何？在下圖可以看到，要造訪這台主機，結果會報 400 Bad Request 錯誤，所以 GeoIP2 模組的確有在好好運作～ 那如果把 HK yes; 改成 HK no; 會如何呢？CN yes; #yes 就是封鎖HK no; #no 就是不封鎖在下圖可以看到主機回覆了 403 錯誤，這是正常的，因為我沒在裡面放東西。不過由此可知，如果沒有造訪的 IP 沒有在我們制定的名單內，就可以正常造訪主機或網站。參考資料 Upgrade to GeoIP2 with NGINX on CentOS/RHEL YUM/DNF Remove Repo – YUM/DNF Disable Repository GeoLite2 Sign Up Sign up for free GeoLite2 databases and web services mmdblookup How install the Geoip2 module on a Nginx running in a production environment?" }, { "title": "架設自己的 Docker Registry", "url": "/posts/Create-docker-registry-24/", "categories": "Docker", "tags": "centos, docker, container, docker registry", "date": "2022-07-11 00:00:00 +0800", "snippet": "使用的環境 系統與使用工具 Centos 7.6 Docker 1.13.1 一、Docker Registry 是什麼？ 開放原始碼的軟體 提供存放 Docker Image 的空間，可與他人共用 可以分為公開或私人的 Registry二、Docker Registry v.s. Docker DistributionDocker Registry 1.0 - Docker Registry 專案Docker Registry 2.0 - Docker Distribution 專案Docker Distribution 專案取代並增強 Docker Registry 專案，同時也朝向更完善且有彈性的 Docker Image 整合管理工具。1. Docker Distribution 專案新增的元件 函式庫：原本由 python 開發，現在改用 golang 規範：相關規範都可以在 Docker Distribution 的 Github Repo 的 docs/spec 資料夾找到 文件：docs 資料夾裡有 docs.docker.com 和 Docker Distribution 相關的說明文件2. Docker Distribution 專案功能的增益項目 更快的 docker push 和 docker pull 執行速度 改善並提升 Docker Registry 的整體運作效能 簡化 Docker Registry 部署方式 提供可插拔的儲存庫後端，可自行選擇上傳後的 Docker Image 儲存方式和位置，可與多種雲端儲存服務整合（AWS S3…等等） 提供 webhook 的通知機制三、Docker Hub 和 Docker CloudDocker Hub 是 Docker 官方提供的免費服務，主要用途是提供 Docker Image 的儲存庫。docker search 和 docker pull 所存取的 Docker Registry 就是 Docker Hub。Docker Cloud 除了利用 Docker Hub 的儲存庫功能，主要用途是提供 Docker 化應用系統（Dockerized application）的完整架構與自動化服務。Docker 化（Dockerized）：把應用程式 Docker 化，把程式跟環境包成一個 image，部署的時候就直接使用這個 image 不需要額外安裝其他東西。如果所開發的應用系統已經 Docker 化或準備 Docker 化，且運行在雲端運算環境，那 Docker Cloud 就可以協助自動化和加速整個應用系統在建版、測試、部署和節點管理上的工作。Docker Hub 和 Docker Cloud 的帳號是共用的，不需要分別註冊，且可以直接在 Docker Cloud 中使用上傳到 Docker Hub 的 Docker Image。四、為何不用 Docker Hub 就好？Docker Hub 是免費且公開的服務，但 Docker Image 的散佈和部署會遇到機密敏感資料與安全考量，以及使用環境的不可用性問題。 機密敏感性的安全問題：Docker Image 可能包含程式碼或不適宜公開的環境設定資訊 公司或組織的環境問題：不同環境有不同考量，譬如開發環境、整合測試、使用者驗證環境、內外網連線以及儲存管理部署 Docker Image 的需求，就會需要在公司內架設專用的 Docker Registry五、架設 Docker Registry1. 下載及啟動 Docker Registry 的 Docker Image架設 Docker Registry 就是啟用一個 Docker Registry 的 Docker Container。# -p 5000：將主機的 5000 port mapping 到 container 的 5000 port$ docker pull registry:2$ docker run -d -p 5000:5000 --name registry registry:2也可以用 -v 掛載資料卷，因為如果 Docker Registry 的資料是放在 Container 裡面，刪掉 Container 時裡面的資料就會跟著不見，所以需要使用 –v 將主機的檔案路徑 mapping 到 Container 裡面的檔案路徑，這樣就算 Docker Container 被刪除， Docker Registry 的 Image 資料還會存在。$ docker run -d -p 5000:5000 -v /usr/local/docker/registry:/var/lib/registry --name registry registry:22. 用指令或瀏覽器確認 Docker Registry 是否啟動成功也可以檢查版本是否為 V2，如果傳回「{ }」，就表示 Docker Registry 已經成功運作。$ curl -LX GET 127.0.0.1:5000/v2{}也可以直接用瀏覽器開啟，如果正常啟動一樣會看到「{}」。http://127.0.0.1:5000/v2如果不是在架設 Docker Registry 的電腦上執行，可以把 IP 位址換成實際的位址：http://x.x.x.x:5000/v2/六、將 Docker Image 上傳到 Docker Registry以下步驟先用 nginx 的 Docker Image 當作範例。1. 標記 Docker Image$ docker tag nginx 127.0.0.1:5000/nginx_local# 如果不是在架設 Docker Registry 的電腦上執行，可以把 IP 位址換成實際的位址$ docker tag nginx x.x.x.x:5000/nginx_local# 查看標記後的 Image$ docker images2. 將 Docker Image push 到 Docker Registry Server$ docker push 127.0.0.1:5000/nginx_local在這邊遇到問題，所以沒有成功將 Docker Image Push 到 Docker Registry 上。這個錯誤訊息主要是因為安全性上的問題，需要修改 client 端的 Docker 設定。insecure-registries：insecure 的意思是非安全性，所以如果是使用 http 協定的 docker registry 就需要設定此參數。$ vim /etc/docker/daemon.json{&quot;insecure-registries&quot;: [&quot;x.x.x.x:5000&quot;]}重新啟動 Docker，並重新 push docker image。$ systemctl restart docker$ docker push 127.0.0.1:5000/nginx_local用瀏覽器開啟查詢：http://127.0.0.1:5000/v2/_cataloghttp://x.x.x.x:5000/v2/_catalog如果要下載剛剛上傳的 nginx_local，就用 docker pull 抓下來。$ docker pull 127.0.0.1:5000/nginx_local$ docker pull x.x.x.x:5000/nginx_local參考資料 Docker 這樣學才有趣：從入門，到玩直播、挖礦" }, { "title": "有關 Feeling 這個分類項目", "url": "/posts/The-first-post-in-feeling-23/", "categories": "Feeling", "tags": "feeling", "date": "2022-07-07 00:00:00 +0800", "snippet": "My Feeling開了一個 Feeling 分類，裡面的文章會簡單地放些照片跟幾段文字。內容有可能是描述照片的情況、當下的心情、突然的感觸，或是歌曲的歌詞、書上看到的很喜歡或有道理的文字，也有可能是無聊的冷笑話。很 Free，主要就是輕鬆小品的概念。順便訓練一下用文字表達心情及想法的能力，平常都被生動的貼圖給養壞了XD" }, { "title": "利用 Docker Compose 管理多個 Container", "url": "/posts/Run-multiple-containers-with-Docker-Compose-22/", "categories": "Docker", "tags": "centos, docker, container, docker-compose", "date": "2022-07-05 00:00:00 +0800", "snippet": "使用的環境 系統與使用工具 Centos 7.6 Docker 1.13.1 docker-compose version 1.18.0 一、Docker Compose 介紹Docker Compose 主要是來管理需要同時運行多個 Docker Container 的狀況。透過 docker-compose.yml 和 docker-compose 指令，加上對 Dockerfile 的支援，快速將多個 Docker Container 分別建立並串接在同一個網路下進行整合，並用簡便的指令來管理同一個 docker-compose.yml 所啟動的 Docker Container。二、什麼情況會需要用到 Docker Compose？ 開發、測試環境或正式運行的生產環境皆可使用 所使用的應用系統會需要連結或整合一個以上的 Container 想達到更彈性和自動化的部署三、一個 Container 或多個 Container？不建議將應用系統需要的服務和元件都放進同一個 Docker Container 裡面，因為設定工作會變複雜，而且這種 Docker Image 在啟動時，會需要更多的環境變數和啟動設定才能順利啟動。建議把應用系統需要的服務和元件都製作成不同的 Docker Image，然後透過 Docker Compose 設定、整合和啟動所需的 Container，這樣能善用分散式運算的能力，每項服務都可以依需要獨立擴充和抽拔，更有效率。四、在 CentOS 安裝 Docker ComposeDocker 和 Docker Compose 是各自獨立的程式，版本號碼也不同步，所以需要分別手動安裝。1. 用 yum 套件安裝$ yum install docker-compose2. 用 pip 安裝# 安裝 pip$ yum install python-pip# 升級 pip$ pip install --upgrade pip# 安裝 docker compose$ pip install docker-compose# 建立連結檔$ ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose安裝完後，查看 Docker Compose 版本：$ docker-compose -v$ docker-compose versiondocker-compose version 1.18.0, build 8dd22a9五、用範例了解 Docker Compose 的運作方式Docker Compose 功能主要是由 docker-compose 指令和 docker-compose.yml 組成。docker-compose 指令可以執行大部分的 docker 指令的選項和功能，但可以直接使用 docker-compose.yml 裡的設定值，而不用像 docker 指令是由選項一一指定。docker-compose.yml 是採用 YAML 檔案格式來撰寫，是一種以「鍵/值 (Key/Value)」方式指定設定變數與設定值的格式，除了 version 標籤外，主要是由 services（服務）、volumes（資料卷）、networks（網路） 等三大標籤所構成。 services：定義和設定此 docker-compose.yml 需要啟動的 Container 資訊，功能和所使用的標籤和 docker run 相似，都是用於啟動 Container volumes：定義給服務使用資料儲存資訊 networks：定義給服務的連結網路資訊而每個 docker-compose.yml 的檔案結構會有 version、services、volumes、networks、configs、secrets 等六個頂層指令組成，後面會講到。1. docker-compose.yml 範例2. 驗證 docker-compose.yml 內容（不會真正執行）$ docker-compose config# -f：指定檔案# -q：如果一切正常，檢查完成後不顯示出任何訊息（原本會顯示完整的 docker-compose.yml 內容）$ docker-compose config -q$ docker-compose -f /usr/local/docker-test/node-red/docker-compose.yml config -q3. 啟動 docker-compose.yml 內所有的服務 用 docker-compose.yml 啟動服務，services 名稱前面預設是資料夾名，可以加上 -p 選項指定專案名稱。# -d：在背景模式執行，如果沒有加上 -d，Container 就會在前景執行$ docker-compose up -d$ docker-compose -p 專案名稱 up -d可以看到剛建立的資料卷及網路前面都會加上「nodered_」字串，是因為那個字串預設會是 docker-compose.yml 所在資料夾的名稱，並會移除資料夾名稱中的非英數字元，如果想指定專案名稱可以加上 -p 選項。4. 執行 docker-compose.yml 內的服務 docker-compose 指令幾乎只接受 services 名稱，而不是 Container 名稱，所以不一定要特別設定 Container 名稱，這樣也可以避免 Container 名稱衝突而無法建立成功。$ docker-compose exec $ docker-compose exec -it db /bin/bash （db 是 services 名稱） 注意！如果是用 docker exec 就要使用 Container 名稱。 docker exec -it node-red-counchdb六、Dockerfile 和 docker-compose.yml 差異 名稱 所屬的腳本檔 用途 Dockerfile docker build 注重在如何產生一個新的 Image docker-compose.yml Docker Compose 比較像 docker run，用來告訴 Docker 如何啟動、運行和連結 Container 七、docker-compose.yml 常用指令1. version用途：指定該 docker-compose.yml 檔案所使用的格式版本。不同的 Docker 及 Docker Compose 版本所支援的 docker-compose.yml 格式和指令略有不同，而 docker-compose.yml 共有三個主要版本，最新版本是 Version 3.8 (2022/07)，各版本差異主要是在 yaml 檔案可以使用的指令數不同，版本越新支援越多指令。docker-compose.yml 版本和 Docker 版本相關，舊版 Docker 上無法用新版的 docker-compose.yml 格式。version: &quot;3&quot;version: &quot;3.0&quot;version: &quot;3.8&quot;2. services用途：指定該 docker-compose.yml 檔案需要啟動的所有的 Container 的啟動及設定資訊。services: node-red: image: xxxxxxxx container_name: xxxxxxxxx3. container_name用途：指定每一個 service 下的 Container 名稱。不過由 docker-compose.yml 啟動的 Container 都可以透過 docker-compose 指令和 services 名稱進行操作，因此 Container 的名稱就不用非要指定。services: node-red: image: xxxxxxxx container_name: node-red-web4. image用途：指定某一個 service 所要使用的 image 檔案名稱和標籤。 用法跟 docker run 和 Dockerfile 的 FROM 相同。image: nginximage: nginx:1.13.3image: ayubiz/nginximage: ayubiz/nginx:1.13.3image: f4114aea5. build用途：另一種取得 image 的方式，只要指定 Dockerfile 所在的資料夾即可。(1) 如果檔案名稱叫做 Dockerfileservices: web: build: /home/ayubiz(2) 如果檔案名稱是自訂的，要多加一個 dockerfile 指令services: web: build: /home/ayubiz dockerfile: ayu.txt(3) 如果需要更改產出的 image 檔案的名稱和標籤，可以同時使用 build 和 image 指令services: web: build: . (目前所在資料夾) image: ayubiz:demo6. command用途：指定 Container 啟動後執行的指令，用以取代掉 Image 檔案內原有的啟動指令（改變 Container 原有的執行指令）。 用法跟 Dockerfile 的 CMD 相同。services: http: image: nginx command: [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]或是services: http: image: nginx command: nginx -g &quot;daemon off;&quot;7. entrypoint用途：覆寫掉 Image 檔案內原有的 ENTRYPOINT 指令。 用法跟 Dockerfile 的 ENTRYPOINT 類似。services: http: image: nginx entrypiont: - nignx - g - &quot;daemon off;&quot;或是services: http: image: nginx command: nginx -g &quot;daemon off;&quot;8. environment用途：用以設定該 services 的環境變數。 用法跟 docker run -e 或是 Dockerfile 的 ENV 類似。平常設定值不需要使用雙引號，不過 YAML 檔會解析 true/false 及 yes/no 這兩組關鍵字，所以會需要加上雙引號避免被轉換成布林值而產生錯誤。services: http: image: nginx environment: USER: ayubiz ROOT: &quot;true&quot; NO_PW:或是# 此種方式能免去減少雙引號的問題services: http: environment: USER: ayubiz ROOT: &quot;true&quot; NO_PW:9. env_file用途：將變數檔案路徑及檔案名稱事先寫在文字檔，並直接引用到 docker-compose.yml 內，可以省去用 environment 逐一設定的麻煩。 注意！同樣的變數名稱，會以 environment 指令的設定為準，如果多個變數檔都有設定同一個變數名時，以最後加入的那個檔案的變數值為主。services: http: image: nginx env_file: aybiz.txt或是services: http: image: nginx env_file: - ./ayubiz.txt - ./env/ayubiz.txt - /tmp/ayubiz.txt10. expose用途：用以設定要啟用的連結埠號。 用法跟 Dockerfile 的 EXPOSE 相同。啟用的連結埠號除了提供給同一個 Docker Network 的其他 Container/Service 存取外，並不能直接給主機的程式使用避免不必要的錯誤發生，加雙引號會比較安全。services: http: image: nginx expose: - &quot;80&quot; - &quot;443&quot;11. ports用途：將主機的連結埠號對應到 Container/Service 所啟用（Expose）的連結埠號，如果沒有要將 Container/Service 所啟用的連結埠號開給主機上的程式或是其他不在同一個 Docker Network 的 Container 所使用就不需要用到。 用法跟 docker run -p 相似。services: http: image: nginx ports: - &quot;80&quot; # 指定主機的 80 埠對應到 Container 的 80 埠 - &quot;8080-8088&quot; # 指定主機的 8080 至 8088 之間的埠號對應到 Container 的 8080 至 8088 之間的埠號 - &quot;80:80&quot; # 指定主機的 80 埠對應到 Container 的 80 埠 - &quot;8080-8090:80-90&quot; # 指定主機的 8080 至 8090 之間的埠號對應到 Container 的 80 至 90 之間的埠號 - &quot;127.0.0.1:8080:80&quot; # 指定主機的 127.0.0.1 網址的 8080 埠號對應到 Container 的 80 埠號 - &quot;127.0.0.1:8080-8090:80-90&quot; # 指定主機的 127.0.0.1 網址的 8080 至 8090 之間的埠號對應到 Container 的 80 至 90 之間的埠號 - &quot;16882:16882/udp&quot; # 指定主機的 16882 埠號對應到 Container 的 16882 埠號的 UDP 通訊協定 12. restart用途：設定 Container 自動重新啟動的模式。 用法跟 docker run --restart 相同。restart 預設值為 no，其他設定值可以是 no、always、on-failure、unless-stopped。services: image: nginx restart: always13. volumes用途：用於掛載主機的資料夾和檔案或外部資料卷到 Container 的指定資料夾或檔案裡 用法跟 docker run -v 相同。(1) services 指令下的 volumes：指定 Container 要掛載的資料卷services: http: image: nginx volumes: # 由 docker 自動建立相同路徑名稱的資料卷掛載到此路徑 - /usr/share/nginx/html # 指定主機的檔案路徑掛載到 Container 的指定路徑 - /home/ayubiz/nginx/html:/usr/share/nginx/html # 將 docker volume 建立的資料卷掛載到 Container 上 - nginx-data:/usr/share/nginx/html(2) 與 services 指令同層的 volumes （頂層）：建立一組新的資料卷用頂層的 volumes 建立一個名為 nginx-data 的資料卷後，就可以使用 services 下的 volumes 將命名好的資料卷進行掛載。services: http: image: nginx volumes: - nginx-data:/usr/share/nginx/htmlvolumes: nginx-data(3) 3.2 版以上 docker-compose.yml 檔案格式支援條列式version: &quot;3.2&quot;services: http: image: nginx volumes: - type: volume source: nginx-data target: /usr/share/nginx/html volume: nocopy: truevolumes: nginx-data14. networks指定 Container 要加入的 Docker Network 名稱。(1) 指定 Container 要加入的 Docker Network 名稱(2) 與 services 指令同層的 networks（頂層）：建立一組新的 Docker Network，提供給 services 指令所定義的 Container/Service 使用 可以使用頂層的 networks 定義多個 Docker Network，且每一個 services 下的 Container 也可以透過 networks 同時加入多個 Docker Network。services: node-red: image: nodered/node-red-docker:slim networks: - node-red-net db: image: counchdb:latest networks: - node-red-netnetworks: node-red-net15. depends_on用途：可以改變 docker-compose.yml 檔案裡面各個 Container/Service 的啟動順序。只要在 node-red 服務下方加上下面的 depends_on，就可以讓 node_red 在 db 啟動完成後再啟動，但可能會發生 node-red 在 db 啟動完成後要啟動，但 Couchdb Server 還沒有啟動完成而無法連線的問題。 注意！啟動完成是指 Container 本身，不是 Container 內的程式或服務啟動完成。services: node-red: image: nodered/node-red-docker:slim depends_on: - &quot;db&quot; db: image: counchdb:latest16. external_links | link這兩個指令大部分已經可以透過 Docker Nerwork 功能自動達成，建議改用 networks 建立 Docker Network 達成相關功能。17. extra_hosts用途：設定其他主機的 IP 和網域名稱做對應，設定完後打開 /etc/hosts 檔案會發現多出剛剛設定的紀錄。 和直接去 Container 的 /etc/hosts 檔案裡加入新的主機的作用相同。services: node-red: image: nodered/node-red-docker:slim extra_hosts: - &quot;webapp1:192.168.1.10&quot; - &quot;webapp2:192.168.99.101&quot;18. dns用途：設定 DNS 伺服器，該服務啟動的 Container 的 DNS 伺服器就會被變更為設定的 DNS 伺服器位址。services&quot; node-red: image: nodered/node-red-docker:slim dns: 9.9.9.9 db: image: couchdb:latest dns: - 168.95.1.1 - 168.95.192.119. labels用途：將 Image 檔的作者、版本、描述、其他自訂資訊儲存到新產生的 Image 檔。 用途和 Dockerfile 的 LABEL 相同。八、Docker Compose 常用指令用 docker-compose 指令操作的好處在於可以對指定的 docker-compose.yml 檔案內所啟動的 Container 做整批的操作，而不需要一個一個處理。docker-compose 指令必須在有 docker-compose.yml 檔案路徑和名稱才能夠正常使用。1. config用途：驗證或檢視 docker-compose.yml 的內容，而不用透過實際執行才能發現錯誤。$ docker-compose config2. build用途：如果 docker-compose.yml 檔案裡有使用到 Dockerfile 來產生 Docker Image 的話，可以使用 build 來產生所需的 Docker Image，但如果 docker-compose.yml 檔案裡沒有指定 Dockerfile，用 build 就不會有任何產出。如果所使用的 Dockerfile 的內容有變動時，也可以使用 build 重新產生 docker image。$ docker-compose build 3. pull用途：下載 docker-compose.yml 中指定要取得的 Image，可指定一或多個服務的名稱，若沒指定就會下載 docker-compose.yml 檔案裡所有指定的 Image 檔。$ docker-compose pull node-red db $ docker-compose pull4. start | stop | restart | pause | unpause | kill用途：啟動、停止、重新啟動、暫停、取消暫停和強制停止 docker-compose.yml 檔案內的 Container。 如果不指定 Container，會預設對 docker-compose.yml 檔案內所有 Container 做操作（譬如：不指定就會停止所有 Container 的運行）。$ docker-compose stop $ docker-compose stop node-red db5. rm用途：移除已經停止運行的 Container，可指定一或多個 Container 的名稱，若沒指定就會移除 docker-compose 檔案裡全部停用的 Container。# -s 可以移除仍在運行中的 Container $ docker-compose rm -v $ docker-compose rm -v node-red $ docker-compose rm -s node-red6. run用途：主要是利用 services 所設定好的各項設定值，然後搭配要執行的命令來啟動服務。docker-compose run 的選項有：-d、--name、--rm、-p、--entrypoint、--workdir、-v、--no-deps。--no-deps：啟動服務時，不去啟動相連或相依的服務。# node-red 是 services 名稱不是 Image 名稱$ docker-compose run node-red 7. up（最常用的指令）用途：將撰寫好的 docker-compose.yml 建立，並啟動所有的服務。用 docker-compose.yml 啟動 Container，若沒另外指定專案名稱，預設是資料夾名。--no-recreate：無論 docker-compose.yml 或 Image 檔有無調整或改變，都不需要重製每個服務所使用的 Container --force-recreate：無論 docker-compose.yml 或 Image 檔有無調整或改變，都要強迫執行重新建立服務所使用的 Container 的動作 注意！ --no-recreate 和 --force-recreate 對於已經啟動的服務的 Container 都會先停止運行後，再依要求只重新啟動或重建後重新啟動。# -d：在背景模式執行，如果沒有加上 -d，Container 就會在前景執行 $ docker-compose up -d $ docker-compose -p 專案名稱 up -d 8. version用途：查看 docker-compose 版本的方式。9. logs用途：查看 Container 所輸出的 log 訊息。 跟 docker logs 用途和用法相同，但 docker-compose logs 不支援以指定的起始時間查詢 log 及額外詳細的 log 顯示方式。10. port用途：查詢 Container 內部的通訊埠所對應的外部 IP 位址和通訊埠號。 與 docker ps 差別在於 docker ps 不用指定要查詢的通訊埠號。# 查詢 node-red 服務的 1880 埠號在 Container 外所對應的 IP 位址和通訊埠號 $ docker-compose port node-red 1880 11. ps用途：顯示所使用的 docker-compose.yml 在 services 項目下定義的 Container 的狀態（包含啟動中和非啟動中），並不是所有的 Container 的狀態。$ docker-compose ps # 只顯示 Container ID 資訊$ docker-compose ps -q 12. help用途：查訊個別指令選項的使用方式和參數$ docker-compose start --help # docker 指令不支援這個操作 $ docker-compose start -? 九、何時要使用 Docker Compose 指令？docker-compose 指令和 docker 指令相同，所以時常會搞不清楚要用那個指令。經過上面可知，docker-compose 指令操作都是基於 docker-compose.yml，如果想要操作的 Container 是由某一個 docker-compose.yml 檔案所定義和產生時，就用 docker-compose 指令來操作，可以少打一些字，因為它會自動去參考 docker-compose.yml 的相關設定。docker-compose 指令可以容易的進行批次操作，可以一次啟用或停用 docker-compose.yml 所定義的所有的 Container，不用像 docker 指令要一一列出想用啟用或停用的 Container。另外，docker 指令使用 Container 名稱作為指令的參數，而 docker-compose 指令則多是以 docker-compose.yml 檔案裡的「服務名稱」來作為參數使用，不直接給 Container 的名稱。參考資料 Docker 這樣學才有趣：從入門，到玩直播、挖礦" }, { "title": "各種自製 Docker Image 的方法", "url": "/posts/Create-docker-image-21/", "categories": "Docker", "tags": "centos, docker, container", "date": "2022-06-16 00:00:00 +0800", "snippet": "使用的環境 系統與使用工具 Centos 7.6 Docker 1.13.1 一、從運行中的 Container 產生 Image 檔 注意事項：(1) 執行 docker commit 時，Container 的狀態是可以停止中的。 (2) 掛載在 Container 的儲存空間不會被存到新產生的 Image 的，需要在 docker run 時再用 -v 掛載。先找一個接近自己需要的 Docker Image 來當基底並 docker run 起來，並用 docker exec 進入這個 Container 來安裝和設定，再用 docker commit 把啟動後產生的變動寫到原來所使用的 Docker Image。# 從運行中的 Container 產生 image 檔$ docker commit &amp;lt;Container 名稱或 ID&amp;gt; &amp;lt;產出的 Docker Image 名稱&amp;gt;# 透過 -m 來增加說明文字，-a 加上作者資訊$ docker commit -m &quot;註解&quot; -a &quot;作者&quot; &amp;lt;Container 名稱或 ID&amp;gt; &amp;lt;產出的 Docker Image 名稱&amp;gt;# 製作一個把 Nginx 預設首頁的訊息從 Welcome 改成 Hello Nginx 的新 Docker Image$ docker pull nginx$ docker run --name nginx-welcome -p 8080:80 -d nginx$ docker cp index.html nginx-welcome:/usr/share/nginx/html$ docker commit nginx-welcome nginx-hello-commit$ docker stop nginx-welcome$ docker images使用 docker images 就可以看到剛剛 commit 出來的 image 檔。再來執行剛剛 commit 出來的 docker-hello-commit，成功！ 二、用 Bulid 指令自動化產生新的 Image Dockerfile 的檔案名稱有大小寫的分別。透過 docker build 和 Dockerfile 就可以以全自動的方式來產生 Image 檔，Dockerfile 可以看成是一個腳本，用來明確告訴 docker build 產生新 Image 所需要用到的資訊和步驟。如果一切都順利，在執行結束後會看到 Successfully built XXXXX，表示已經成功建立！docker build 執行完成後，用 docker images 查詢，可以看到剛剛建立的 Image。# 自動化產生新的 Image$ docker build -t &amp;lt;新產生的 Image 的名稱：版本&amp;gt; &amp;lt;Dockfile 所在的檔案路徑或網址&amp;gt;$ cd nginx-docker$ docker build -t nginx-ayu:demo .$ docker build -t nginx-ayu:demo http://xxx.xxxx.xxx.xxx三、Dockerfile常用的指令和格式1. FROM用途：指定要下載的 Image 檔名稱。從 Docker Hub 下載 Debain 的 Jessie 版本的 Image 檔。FROM debain:jessie2. ENV用途：設定環境變數。在 Container 裡設定指定 Nginx 的 NGINX_VERSION 環境變數。之後執行 apt-get install 安裝指令時，會需要這個 ENV 所設定的變數，通常會把經常變動的參數設成環境變數，以便後續維護或更新時，可以不用直接修改相關的指令。ENV NGINX_VERSION 1.11.10-1~jessie3. EXPOSE用途：指定 Container 啟用的連結埠號。設定這個 Container 要啟用 80 和 443 port，透過 EXPOSE 啟用的連結埠不能被外部或主機連線存取，必須透過 docker run 的 -p 選項設定，主機的連線或程式才可以透過該對應的主機連結埠進行連結及存取。EXPOSE 80 4434. RUN用途：建立 Image 時執行的指令，只有在 docker build 產生的時候會有作用，大部分被用在設置和安裝軟體。# 利用 RUN 指令在這個暫時啟用的 Container 執行安裝的指令RUN apt-key adv --keyserver ........5. CMD用途：Container 啟動完成後要執行的指令。 注意！每個 Dockerfile 只能有一個 CMD 指令會有作用，若同一個 Dockfile 裡有多個 CMD 指令，只有 最後一個 CMD 指令會有作用。(1)（官方建議寫法）可用在 Dockfile 裡，但不會使用預設的 Shell 執行，不能使用 Shell 所提供的功能，像是取用環境變數或用 Shell 內建的指令。CMD [&quot;&amp;lt;要執行的程式&amp;gt;&quot;,&quot;&amp;lt;要執行的程式用到的第一組選項&amp;gt;&quot;,&quot;&amp;lt;要執行的程式用到的第二組選項或第一組選的參數值&amp;gt;&quot;](2) 可用在 Dockfile 裡，會使用預設的 Shell 執行。CMD &amp;lt;要執行的程式&amp;gt; &amp;lt;要執行的程式用到的第一組選項&amp;gt; &amp;lt;要執行的程式用到的第二組選項或第一組選的參數值&amp;gt;(3) 搭配 ENTRYPOINT 指令使用，傳遞指令選項給 ENTRYPOINT 指令使用。CMD [&quot;&amp;lt;加在 ENTRYPOINT 執行程式的選項一&amp;gt;&quot;,&quot;&amp;lt;加在 ENTRYPOINT 執行程式的選項二&amp;gt;&quot;]當 Container 啟動完成後，要求 Container 啟動 Nginx，就等於在 Container 命令列執行 $ nginx -g daemon off。CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;] # daemon off 是 -g 選項的參數，且要求須使用雙引號 CMD nginx -g, &quot;daemon off;&quot; 6. ENTRYPOINT用途：用法和 CMD 相似，都是用來設定 Container 啟動後要執行的指令，但如果是用 ENTRYPOINT 指令來啟動程式的話，就不能在 docker run 後面加入執行指令來蓋掉 ENTRYPOINT 所要求的啟動方式，反而會變成 ENTRYPOINT 的後續選項。(1) 官方建議寫法ENTRYPOINT [&quot;&amp;lt;要執行的程式&amp;gt;&quot;,&quot;&amp;lt;要執行的程式用到的第一組選項&amp;gt;&quot;,&quot;&amp;lt;要執行的程式用到的第二組選項或第一組選的參數值&amp;gt;&quot;](2)ENTRYPOINT &amp;lt;要執行的程式&amp;gt; &amp;lt;要執行的程式用到的第一組選項&amp;gt; &amp;lt;要執行的程式用到的第二組選項&amp;gt;假如有個 Dockfile 最後一行從 CMD 改成 ENTRYPOINT [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;] 後產生新的 Image 檔，就會發生錯誤，因為 /bin/bash 會變成 ENTRYPOINT 的後續選項： [nginx -g &quot;daemon off;&quot;/bin/bash]，而 Nginx 沒有 /bin/bash 選項$ docker build -t nginx-entrypoint .$ docker run -it nginx-entrypoint /bin/bash發生錯誤！7. WORKDIR用途：指定執行指令的資料夾位置 注意！當資料夾是相對路徑時，預設會以它上一個 WORKDIR 指令所指定的資料夾位置做為目前所在的資料夾位置。如果用到 RUN、CMD、ENTRYPOINT、COPY、ADD 指令，便會需要利用 WORKDIR 來進行資料夾位置轉換。WORKDIR &amp;lt;資料夾完整路徑或相對路徑&amp;gt;建立 /home/ayubiz/abc 資料夾後，利用 WORKDIR 切換到 /home/ayubiz 資料夾，然後把 hello.html 檔案複製到 /home/ayubiz 裡，透過 WORKDIR 指定相對位置 abc 資烙夾將位置切換進 /home/ayubiz/abc，同時這也是使用 docekr exec 進入新啟動的 Container 後的所在位置。RUN mkdir -p /home/ayubiz/abcWORKDIR /home/ayubizCOPY hello.html ./WORKDIR abc8. ADD 需要解自動解壓縮(.tar)時適用。用途：將一個或多個檔案放進 Image 裡，讓 Dockfile 所產生的 Image 檔能包含這些檔案。ADD &amp;lt;來源檔案在主機的完整路徑和檔名&amp;gt; &amp;lt;Image 的完整目的路徑和檔名&amp;gt;ADD &amp;lt;來源檔案完整網址和檔名&amp;gt; &amp;lt;Image 的完整目的路徑和檔名&amp;gt;ADD 指令支援 * 和 ? 等符號的萬用字元將 Dockfile 所在目錄下的 hello.html 檔案加到新產生的 Image 檔的 /usr/share/nginx/html 資料夾。ADD hello.html /usr/share/nginx/htmlADD *.html /usr/share/nginx/htmlADD hello.htm? /usr/share/nginx/html 注意！如果在路徑最後加上 / ，都會被認為是一個資料夾位置而不是檔案，若檔案來源路徑是資料夾，資料夾內的檔案會被加到 Image 檔案中，但資料夾本身不會被加入。也就是說 docker build 不會自動在 Image 檔案裡新增來源檔案的資料夾後再加入來源資料夾內的檔案，但是當目的地檔案是資料夾時，docker build 會自動建立不存在的資料夾。例如：ADD ./abc/ /demo/docker build 會新增 demo 資料夾，然後將 abc 資料夾底下的所有檔案加到 demo 資料夾裡，但是 demo 資料夾裡不會有 abc 資料夾的存在。9. COPY用途：功能跟 ADD 類似，如果沒有要自動解壓縮檔案，官方還是比較建議用COPY。COPY &amp;lt;來源檔案在主機的完整路徑和檔名&amp;gt; &amp;lt;Container 裡的完整目的路徑和檔名&amp;gt;10. MAINTAINER用途：標註此 Dockerfile 的作者或維護者 此指令要被淘汰，建議之後用 LABEL 指令。如果要把 Dockfile 分享出去，建議寫上電子郵件。MAINTAINER NGINX Docker Maintainers &quot;docker-maint@nginx.com&quot;11. LABEL用途：將 Image 檔的作者、版本、描述、其他自訂資訊儲存到新產生的 Image 檔，建議將多欄位與值都使用一個 LABEL 來執行。LABEL &amp;lt;欄位名稱&amp;gt;=&quot;&amp;lt;欄位值&amp;gt;&quot; &amp;lt;欄位名稱&amp;gt;=&quot;&amp;lt;欄位值&amp;gt;&quot; &amp;lt;欄位名稱&amp;gt;=&quot;&amp;lt;欄位值&amp;gt;&quot; LABEL version=&quot;0.1&quot; description=&quot;demo&quot; organization=&quot;arthurtoday.com&quot;存入的資訊可以透過 docker image inspect 查看 Labels 欄位。$ docker inspect -f &#39;{{json .ContainerConfig.Labels}}&#39; &amp;lt;Image 名稱或 ID&amp;gt;12. USER用途：指定新產生的 Image 檔的預設使用者帳號（通常都是 root），要先用 RUN 建立新使用者，USER 指令不會自動建立新帳號，如果指定不存在的使用者帳號是不會有作用的。使用者帳號會影響到 RUN、CMD、ENTRYPOINT 等指令的執行時所用的使用者帳號，也會影響權限，所以若非必要，不建議使用 USER 指令改變執行軟體的使用者。USER &amp;lt;已建好的使用者名稱&amp;gt;USER &amp;lt;已建好的使用者 UID&amp;gt;USER &amp;lt;已建好的使用者名稱&amp;gt;:&amp;lt;已存在的使用者群組名稱&amp;gt;USER &amp;lt;已建好的使用者 UID&amp;gt;:&amp;lt;已存在的使用者群組 UID&amp;gt;13. VOLUME用途：提供在 Image 檔案建立 Data Volume 掛載點的功能。Volume [&quot;&amp;lt;掛載點的資料夾名稱和完整路徑&amp;gt;&quot;, ...]Volume &amp;lt;掛載點的資料夾名稱和完整路徑&amp;gt; ...把 Nginx 的 Image 檔裡的 /usr/share/nginx/html 和 /var/log/nginx 設定為掛載點的方式。Volume [&quot;/usr/share/nginx/html&quot;,&quot;/var/log/nginx&quot;]Volume /usr/share/nginx/html /var/log/nginx也可以用 RUN 指令建立資料夾，再使用 VOLUME 設定掛載點。RUN mkdir /tempVolume /temp14. ARG用途：可以讓 docker bulid 指令利用 --build-arg 選項傳入參數到 Dockerfile 裡，可以增加 Dockfile 的彈性和再利用性。有時候某些參數變更就需要修改 Dockerfile，譬如更改環境變數，如果不想經常更改 Dockerfile，可以考慮改用 ARG 指令搭配 docker buil 的 --build-arg 選項。(1) 只給定參數名稱ARG &amp;lt;參數名稱&amp;gt;(2) 同時給定參數的名稱和預設值，不一定需要設定預設值ARG &amp;lt;參數名稱&amp;gt;=&amp;lt;預設值&amp;gt;把 ENV 指令的 NGINX_VERSION 改用 ARG 指定設定為參數和預設值，然後如果要更改，就可以利用 docker build --build-arg 指定 NGINX_VERSION 值。ARG NGINX_VERSION=1.13.4-1~jessie$ docker build -t nginx-ayu7 . --build-arg NGINX_VERSION=1.11.20-1~jessie 注意！如果有相同名稱的變數，ENV 指令會優於 ARG 指令。ARG NGINX_VERSION=1.13.4-1~jessieENV NGINX_VERSION=1.11.10-1~jessieRUN echo $NGINX_VERSION最後會 echo 出 1.11.10-1~jessie四、Dockerfile 撰寫與 docker build 指令建議做法 資料夾每一個 Dockfile 都放置各自獨立的資料夾，並把所需的檔案都集中放置到資料夾內，執行 docker build 前也移到該資料夾後再執行，這樣可以簡化 Dockerfile 的撰寫和 docker build 指令的執行。 一次一種用途Container 和虛擬機器不同，不適合讓一個 Container 當成一個機器來執行很多功能，建議讓多個 Container 來組合成一個完整的架構，這樣 Dockfile 才能易寫易懂易維護，同時還可以利用 Container 的分散運算能力提高整個系統的可用性 只安裝需要的套件Image 檔案的大小有一部份是取決於安裝軟體數的多寡，改 Dockfile 和 重新產生 Image 的速度很快，有需要再修改 Dockerfile 就好了，不要為了以防萬一而加大 Image 檔案的容量，導致增加檔案傳輸或部屬的時間 Build Cache 善用 docker build 指令在產生 Image 檔時，背後有使用到一個快取的機制，所以同一個 Dockerfile 在執行第二次或第三次的 docker build 指令時可以發現產生的速度快很多，因為有 Build Cache 機制在運作。但是 Build Cache 的作用和行為會依 Dockfile 被修改的內容而不同，如果發現執行 docker build 後產出的 Image 檔和預期的不同，可以加入 docker build --no-cache 停用 Cache，以確定問題不是 Cache 造成 五、用匯出和匯入的方法搬移 Image 檔1. 匯出docker save 指令匯出的檔案為 tar。$ docker save -o &amp;lt;匯出的檔案名稱.tar&amp;gt; &amp;lt;要匯出的 Image&amp;gt;:&amp;lt;版本&amp;gt;$ docker save -o nginx.tar nginx:latest$ docker save -o nginx.tar nginx$ docker save nginx &amp;gt; nginx.tar2. 匯入如果主機上已經有相同的名稱和版本的 Image 檔存在，可能會顯示已匯入但實際上沒覆蓋。$ docker load -i &amp;lt;之前匯出的 image 檔.tar&amp;gt;$ docker load -i nginx.tar$ docker load &amp;lt; nginx.tar六、用 Container 匯出成新的 Image 檔除了使用 docker commit 指令產生新的 Image 檔，也利用 docker export 匯出 Container，再用 docker import 產生新的 Image 檔。1. 匯出不是將運行中的 Container 整個匯出，而只是將 Container 內部使用中的檔案系統匯出，匯出的檔案會覆蓋相同路徑下的同名稱檔案。如果 Container 有掛載 Date Volume，則資料卷不會被匯出。$ docker export -o [匯出的檔案名稱.tar] [Container 名稱或 ID]$ docker export [Container 名稱或 ID] &amp;gt; [匯出的檔案名稱.tar] $ docker export -o nginx-export.tar nginx-hello2. 匯入匯入時，不會將匯入的檔案內容轉換成運行或停用的 Container，而是直接匯入成 Image 檔，所以可以利用這種特質，將執行中的 Container 檔案內容在同一台或不同主機上，匯出新的 Image 檔。$ docker import [匯入的檔案名稱與路徑] [Image 名稱：版本標籤]$ docker import nginx-export.tar ayubiz/nginx:hello$ docker images參考資料 Docker 這樣學才有趣：從入門，到玩直播、挖礦" }, { "title": "Nginx.conf 的結構", "url": "/posts/Nginx-conf-20/", "categories": "Nginx", "tags": "nginx", "date": "2022-05-31 00:00:00 +0800", "snippet": "使用的環境 系統與使用工具 Centos 7.6 nginx/1.16.1 一、nginx.conf 設定檔內容Nginx 的設定檔是 nginx.conf，檔案位置通常是在 /etc/nginx/nginx.conf 或 /usr/local/nginx/conf/nginx.conf。 ... #全區塊 event #events區塊{ ...} http #http區塊{ ... #http全區塊 server #server區塊 { ... #server全區塊 loaction [PATTERN] #location區塊 { ... } loaction [PATTERN] #location區塊 { ... } } server #server區塊 { ... } ... #http全區塊}二、nginx.conf 檔案結構nginx.conf 一共由三部分組成： 全區塊 events 區塊 http 區塊 http 全區塊 多個 server 區塊（包含 server 全區塊、多個location 區塊） 三、nginx.conf 檔案結構注意事項 同一個設定區塊中巢狀結構的設定區塊，各個之間不存在次序關係 高一級區塊中的指令，可以作用於本身所在的區塊和此區塊包含的所有低階級區塊。 如果某個指令在兩個不同層級的區塊中同時出現，則採用「就近原則」，即以較低層級區塊中的設定為準。四、各區塊解釋1. 全區塊(1) 作用域是 Nginx 全域。(2) 設定影響 Nginx 伺服器整體執行的設定指令。(3) 通常設定包含： Nginx 伺服器的使用者（群組） 允許產生的 worker process 數 Nginx 處理行程 PID 儲存路徑 紀錄檔的儲存路徑 設定檔的引用2. events 區塊(1) 設定影響 Nginx 伺服器與使用者的網路連接。(2) 通常設定包含： 是否開啟對多 worker process 下的網路連接進行序列化 是否允許同時接收多個網路連接 選取哪種事件驅動模型處理連接請求 每個 worker process 可以同時支援的最大連接數3. http 區塊 這裡講的 「http 全區塊」 表示 http 自己的全區塊，意思是 http 區塊中不包含在 server 區塊的部分。(1) 最重要的一部分，包含代理、快取、協力廠商模組設定、紀錄檔定義等絕大多數的功能。(2) http 全區塊通常設定包含： 檔案引用 MIME-Type 定義 紀錄檔自訂 是否使用 sendfile 傳輸檔案 連接逾時間 單連接請求數上限4. server 區塊(1) 此區塊和 「虛擬機器」的概念有密切聯繫，虛擬機器的技術使得 Nginx 伺服器可以在同一台伺服器上只執行一組 Nginx 處理行程，就可以執行多個網站。(2) 每個 http 區塊包含多個 server 區塊，而每個 server 區塊就相當於一台虛擬主機，它內部可有台主機聯合提供服務，一起對外提供一組服務或網站。(3) 通常設定包含： 本虛擬主機的監聽設定 本虛擬主機的名稱或 IP 設定5. location 區塊(1) 每個 server 區塊包含多個 location 區塊，嚴格來說，location 其實是 server 區塊的指令(2) location 區塊的主要作用： 對特定請求進行處理 ex. Nginx 伺服器接收到的請求字串(server_name/uri-string)，除去虛擬主機名稱或 IP 之外的字串(/uri-string)進行比對 位置定向 資料快取 回應控制 協力廠商模組設定參考資料 Nginx技術手札：網頁伺服器應用全攻略" }, { "title": "Docker Container 的進階操作", "url": "/posts/Advanced-Docker-Operations-19/", "categories": "Docker", "tags": "centos, docker, container", "date": "2022-05-30 00:00:00 +0800", "snippet": "使用的環境 系統與使用工具 Centos 7.6 Docker 1.13.1 一、幫 Container 取名字# 執行 Container 時，加上 --name 可同時命名該 Container 的名字# 若是不取名，就會有 Docker 自動產生的名字$ docker run --name &amp;lt;Container 名稱&amp;gt; -p &amp;lt;對外的埠號&amp;gt;:&amp;lt;預設的埠號&amp;gt; -d &amp;lt;Docker Image 名稱&amp;gt;# 把 nginx Container 取名成 nginx$ docker run --name nginx -p 8080:80 -d nginx$ docker ps -aContainer 有自訂名稱後，就可以用指令去操作。$ docker stop nginx$ docker start nginx$ docker restart nginx$ docker rm nginx二、將 Container 設定環境變數有些軟體的 Container 啟動時要同時設定好一些變數讓它可以讀取來做為初始的設定值，例如：預設的管理者帳號密碼、預設執行目錄、同意軟體授權等參數設定。# 執行 Container 的同時加上 -e 可以設定變數值docker run -e &amp;lt;變數名稱&amp;gt;=&amp;lt;變數值&amp;gt; -p &amp;lt;對外的埠號&amp;gt;:&amp;lt;預設的埠號&amp;gt; -d &amp;lt;Docker Image 名稱&amp;gt;# MySQL 資料庫需要事先透過 MYSQL_ROOT_PASSWORD 指定資料庫管理者密碼# 一開始先指定 root 密碼是 123456789，成功啟動後再用 docker exec 執行 mysql 操作 MySQL，就可以用剛剛設定的密碼成功登入$ docker run --name mysql -e MYSQL_ROOT_PASSWORD=123456789 -d mysql$ docker exec -it mysql mysql -p三、docker run v.s. docker create?docker create 要建立一個新的 Container，需搭配 docker start 指令才會啟動，docker run 在執行之後就會立刻運行。docker run --name nginx-run -p 8080:80 -d nginx-&amp;gt; 下指令後，Container 的狀態會是 UPdocker create --name nginx-create -p 8081:80 nginx-&amp;gt; 下指令後，Container 的狀態會是 Created四、外掛 Container 的儲存空間，把資料存下來如果資料是放在 Container 內，當 Container 掛掉且不得不刪掉時（通常 exit code 不等於 0 就會強制刪掉 Container），裡面的資料也會跟著一起被刪掉，所以將儲存空間外掛是比較保險且安全的方式。而且，假設使用資料庫的 Container，資料庫檔案位置會是在 Container 內部，當不斷把資料寫進資料庫，用 docker ps -a 查看會發現 Container 佔用的空間會不斷的長大。Docker Container 的檔案系統是用疊層（Layer）的方式儲存，會比常見的檔案儲存更耗空間（用一種層疊的方式來新增資料，每次新增資料，就會產生一層新資料層來疊在原來所使用的 Docker Image 上）。直接把資料庫檔案存在 Container 內部，就會因為產生大量的新資料層而快速吃掉硬碟空間，如果之後想把資料帶走，就要匯出這個 Container 來產生新的 Docker Image，超級麻煩。所以就可以外掛 Container 的儲存空間，把資料另外存下來。# 執行 Container 的同時加上 -v 可以掛上外部的硬碟空間$ docker run -v &amp;lt;外部資料夾或檔案的完整路徑&amp;gt;:&amp;lt;Container 內部要被取代的資料夾完整路徑&amp;gt; -p &amp;lt;對外的埠號&amp;gt;:&amp;lt;預設的埠號&amp;gt; -d &amp;lt;Docker Image 名稱&amp;gt;# nginx Container 內的 /usr/share/nginx/html 資料夾改成主機上的 /var/www 來取代# 如果主機上沒有 /var/www 資料夾存在，docker run 會自己新增$ docker run -v /var/www:/usr/share/nginx/html -name nginx-store -p 8080:80 -d nginx# 除了可以取代資料夾，也可以取代檔案，常見用法是取代設定檔，用預先自訂好的設定檔取代 Docker Image 內建的設定檔# 將本機上的 /home/nginx-test/nginx.conf 取代 Container 內的 /etc/nginx.nginx.conf$ docker run -v /home/nginx-test/nginx.conf:/etc/nginx/nginx.conf -v /var/www:/usr/share/nginx/html -name nginx-store -p 8080:80 -d nginx五、直接執行 Container 內的程式或指令有些 Container 用途是被當作軟體工具包，docker run 可以直接在最後面加上想要執行的指令，讓 Container 一啟動完成後就執行指定的指令。$ docker run &amp;lt;Docker Image 名稱&amp;gt; &amp;lt;指令完整檔案路徑與名稱及指令選項&amp;gt;# 想在 Windows 環境用 ls 操作# 使用 ubuntu 的 ls 指令，但這樣只會把 ubuntu Container 跟目錄的檔案列出來# 所以想要把 Windows 上的某個資料夾檔案清單列出就要搭配 -v，將主機的資料夾掛載到 Container 裡面，讓 Container 內的程式可以看的到它，進而用做各項操作$ docker run ubuntu /bin/ls$ docker run -v C:\\downloads:/home/test ubuntu /bin/ls -l /home/test六、讓 Container 在執行結束後自動移除被啟動的 Container 停止後就會自我毀滅~$ docker run --rm -v C:\\downloads:/home/test ubuntu /bin/ls -l /home/test七、讓 Container 掛掉後自動重新啟動，或開機後自動啟動docker run 可以使用 --restart 來決定要不要嘗試自動重新啟動 Container。docker run --restart 的選項有：no、always、unless-stopped、on-failure no：預設值，不自動重新啟動。 always：（exit code 必須是正常值=0）可以達到電腦開機就自動啟動 Container 的效果，因為這個 Container 會跟 Docker 本身的 Daemon 綁在一起，所以 Docker 只要一啟動，有 --restart=always 的 Container 就會跟著啟動。 unless-stopped：（exit code 必須是正常值=0）Container 會自動啟動，但是不會在電腦開機時自動啟動。 on-failure：exit code 不等於 0 時自動啟動，因為若 exit code 不等於 0 代表可能是錯誤造成的退出或結束，通常會指定自動重啟的次數，以防造成無窮啟動迴圈。$ docker run --restart=always nginx$ docker run --restart=unless-stopped nginx$ docker run --restart=on-failure:5 nginx八、進入 Container 操作命令列 用 docker run 也可以 -&amp;gt; docker run -it --name nginx-cmd nginx /bin/bash# -i：互動模式# -t：把指令執行結果送出來$ docker exec -it &amp;lt;Container 名稱或 ID&amp;gt; &amp;lt;指令完整檔案路徑與名稱及指令選項&amp;gt;# 進入 nginx 操作命令列$ docker run --name nginx-cmd -d nginx$ docker exec -it nginx-cmd /bin/bash九、Container 綁定指定的 IP 位址（正式的服務環境必用）如果只有指定埠號而沒有指定 Container 要綁到哪個 IP 位址，預設會綁定到主機的 0.0.0.0，表示這個主機上的任一組 IP 都可以連到這個 Container。# 指定 Container 綁定 IP位址$ docker run -p &amp;lt;主機的 IP 位址&amp;gt;:&amp;lt;主機的連接埠號&amp;gt;:&amp;lt;Container 的連接埠號&amp;gt; -d &amp;lt;Docker Image 名稱&amp;gt;# 假如主機上有兩個網站、兩組 IP 位址，分別是 192.168.1.1 和 10.0.1.1，如果想要用 192.168.1.1 來連到這個 nginx container：$ docker run -p 192.168.1.1:80:80 -d nginx# 如果只想讓主機自己可以連上：$ docker run -p 127.0.0.1:80:80 -d nginx十、建立多個 Container 專用的 Docker 網路 除了 docker network 之外，docker run 有個 --link 選項也可以把兩個 Container 串接在一起，不過限制多，官方也不建議繼續使用 Docker link 的功能，還是建議用 Docker 網路，不然就是用 Docker Compose 來達到。# 建立 Docker 網路$ docker network create &amp;lt;Docker 網路名稱&amp;gt;# 啟動 Container 並加入網路$ docker run --name=&amp;lt;Contianer 名稱&amp;gt; --net=&amp;lt;網路名稱&amp;gt;很多時候都會需要運行兩個以上的軟體，例如使用部落格軟體，就會同時用到網頁伺服器和資料庫系統。在虛擬機時，會把網站伺服器跟資料庫系統這兩套都安裝同一個虛擬機上。但在 Container 上，就不建議這樣的作法，比較建議用 docker network 建立一個 Docker 網路，然後再把這兩套軟體分別啟動為獨立的 Container，同時在 docker run 的時候，利用 --net 選項將這兩個 Container 加到同一個 Docker 網路之中。# 建立 nginx-a 和 nginx-b 兩個 Container 然後加入到 nginx-net 的 Docker 網路，然後 nginx-a 用 ping 指令加上 nginx-b 的 Container 名稱就可以 ping 到 nignx-b，而不用知道 nginx-b 的 IP$ docker network create nignx-net$ docker run --name nginx-a --net=nginx-net -p 8100:80 -d nignx$ docker run --name nginx-b --net=nginx-net -p 8101:80 -d nignx$ docker exec -it nginx-a /bin/bash root@e8b718be1d25:/# ping nginx-b十一、查看及刪除 Docker 網路# 可以在輸出結果的 [Containers] 項目查到已加入此 Docker 網路的 Container ID$ docker network inspect &amp;lt;Docker 網路名稱&amp;gt;# 刪除 Docker 網路$ docker network rm &amp;lt;Docker 網路名稱&amp;gt;Docker 網路被移除後，所有已加入該 Docker 網路的 Container 都會無法再被啟動，因為它們會找不到需要的 Docker 網路可用。如果需要再次啟動那些 Container，只能建立一個相同名稱的 Docker 網路。十二、docker stop v.s. docker kill?建議使用 docker stop 來關閉 Container。docker stop 會讓 Container 進入標準的關機行程，也就是說會讓 Container 收到要關機的訊號，並通知各個行程進入各自的關機處理行程（像是資料同步或更新到檔案等工作）。docker kill 是當遇到使用 docker stop 關閉不了，需要強制關閉的狀況時來使用。$ docker stop &amp;lt;Container 名稱或 ID&amp;gt;$ docker kill &amp;lt;Container 名稱或 ID&amp;gt;十三、當運行中的軟體推出新版本時，如何升級？更新的方式就是下載最新版的 Docker Image，然後再重新啟動新的 Container 就好。更新過程中會有 Container 停止和重新啟動的需要，所以在更新之前要先規劃及準備好所需資料。有些事項要特別注意，才可以做到只下載新版 docker image 和用 docker run 重新啟動 Container 就可以完成更新的做法：(1) 不要在 Container 內儲存任何資料和設定(2) 要記下啟動 Container 時所使用的 docker run 指令和選項及參數# 檢視或備份運行中的 Container 資訊$ docker inspect &amp;lt;Container 名稱或 ID&amp;gt;# 取回最新版的 Docker Image$ docker pull &amp;lt;Image 名稱&amp;gt;# 停止運行中的 Containerdocker stop &amp;lt;Container 名稱或 ID&amp;gt;# 移除 Containerdocker rm &amp;lt;Container 名稱或 ID&amp;gt;# 重新啟動 Containerdocker run &amp;lt;原來的選項與參數&amp;gt;十四、建立專用 Data Volume 儲存資料 除了用 docker run -v 和 docker volume 來建立 Data volume，也可以使用 docker-compose 指令搭配 docker-compose.yml 檔案新增 Data volume。用 docker run -v 可以直接從主機存取 Container 的檔案，但是容易發生權限的問題，無法順利存取。另一個方法是可以透過建立 Docker Data volume 永久性存放 Container 的資料，還可以”共用”或”回收”。(1) docker run -v 自動建立的 Data volume沒有指定外部資料夾的路徑，而是直接指定該 Container 的 /usr/share/nginx/html 資料夾要掛載外部的 Data volume。docker run 會在啟動 Container 時，立即建立一組 Data volume，並掛載此 Data volume 至 Container 的 /usr/share/nginx/html 資料夾路徑上，同時，還會自動把該資料夾內的檔案複製到此新建的 Data Volume 裡。用這方式建立的 Data volume 名稱是隨機的，不過可以使用 docker inspect &amp;lt;Container 名稱或 ID&amp;gt; 來查詢。$ docker run -v /usr/share/nginx/html --name=nginx-vol -p 8080:80 -d nginx# 查看該 Container 的 Data volume$ docker volume ls # 使用 docker inspect 找出自動建立的 Data volume 的名稱（用 docker run -v 建立的 Data volume 無法命名）$ docker inspect --format=&#39;{{json .Mounts}}&#39; nginx-volName: 新建的 Data Volume 名稱。Source: Data volume 在主機的實際位址和路徑。(2) docker volume create 建立的 Data volume$ docker volume create &amp;lt;volume 名稱&amp;gt;# 建立名叫 nginx-html 的 data volume$ docker volume create nginx-html# 查看一下剛剛建立的 Data volume$ docker volume ls # 將 docker volume create 建立的 Data volume 掛載到新啟動的 Container 的 /usr/share/nginx/html 上$ docker run -v nginx-html:/usr/html/nginx/html --name nginx-vol -p 8080:80 -d nginx可以將這個 Data volume 同時共用到其他 Container 上面，指令跟上面一樣。不過共用的話要考量到”共用讀寫”同一檔案的問題，如果多個 Container 共用一個 Data volume 最好還是以不會共同更新同一個檔案的前題為原則，以免資料混亂或錯誤。$ docker run -v nginx-html:/usr/html/nginx/html --name nginx-vol2 -p 8080:80 -d nginx(3) 查看 Docker Data volume 的詳細資訊$ docker volume inspect &amp;lt;volume 名稱&amp;gt;$ docker volume inspect nginx-html(4) 刪除 Docker Data volumeData volume 不會自動被刪除，必須要手動操作刪除指令，且必須刪除綁著此 Data volume 的 Container 才能刪除該 Data volume。$ docker volume rm &amp;lt;Data volume 名稱&amp;gt;參考資料 Docker 這樣學才有趣：從入門，到玩直播、挖礦" }, { "title": "Docker 基本指令", "url": "/posts/Docker-Command-18/", "categories": "Docker", "tags": "centos, docker, container", "date": "2022-05-28 00:00:00 +0800", "snippet": "使用的環境 系統與使用工具 Centos 7.6 Docker 1.13.1 一、找到要用的映像檔（Image）1. 尋找某個 Docker Image$ docker search &amp;lt;軟體名稱&amp;gt;# 尋找 nginx 的 Image 檔$ docker search nginx2. 下載搜尋到的 Docker Image&amp;lt;Docker Image 名稱&amp;gt; 就是 docker search 指令執行結果所顯示的 [NAME]$ docker pull &amp;lt;Docker Image 名稱&amp;gt;# 下載 nginx 的 Image 檔$ docker pull nginx3. 查看已經下載過的 Docker image 檔$ docker images二、啟動一個 Docker Container# 以 Detach 的方式啟動一個 Container$ docker run -p [對外的埠號]:[預設的埠號] -d# 啟動 nginx 的 Docker Images$ docker run -p 8080:80 -d nginx上述例子是要用 nginx 的 docker images 以 Detach 的方式在主機的 8080 port 上提供服務，所以啟動這個 Container 後，可以在瀏覽器上用 http://127.0.0.1:8080 開啟網頁。三、解決 Container 啟動後就結束的問題Container 在作業系統也是被視為一隻執行中的行程（Process），所以如果 Docker 裡面執行不是伺服器般的軟體，就會像跑一隻程式一樣，跑完就結束（像 Ubuntu 或 Node.js），如果 Container 一啟動就結束的話，可以在 Container 啟用一個持續執行中的程式，保持運行。四、看看啟動過哪些 Container顯示出所有啟動過的 Container 的清單（包括正在執行與停止的）# -a: 可以看到已經中斷運行和正在運行的 Container $ docker ps -aSTATUS: 顯示 Container 已經啟動多久了。五、啟動和停止和重新啟動 Container(1) 啟動 Container$ docker start &amp;lt;Container ID&amp;gt;# &amp;lt;Container ID&amp;gt; 通常輸入前四碼就可以$ docker start b87ea384818a# 或$ docker start b87e(2) 停止 Container$ docker stop &amp;lt;Container ID&amp;gt;# &amp;lt;Container ID&amp;gt; 通常輸入前四碼就可以$ docker stop b87ea384818a# 或$ docker stop b87e(3) 重新啟動 Container$ docker restart &amp;lt;Container ID&amp;gt;# &amp;lt;Container ID&amp;gt; 通常輸入前四碼就可以$ docker restart b87ea384818a# 或$ docker restart b87e六、移除不再使用的 ContainerContainer 的狀態要在”停止”的狀態才可以移除，且移除掉後無法再使用 start 和 restart 再啟動，先前啟動後所產生的資料也會不見。$ docker rm &amp;lt;Container ID&amp;gt;# &amp;lt;Container ID&amp;gt; 通常輸入前四碼就可以$ docker remove b87ea384818a# 或$ docker remove b87e七、刪掉一些不用的 Docker ImageDocker Image 會吃掉一部分的碟空間，所以沒用到的可以刪一刪，且 Docker Image 是一層一層疊出來的，不同的 Docker Images 可能有共用到同一個層的部分， 所以移除掉某個 Docker Image 後所拿回的硬碟空間不一定會跟所想的一樣。這也是為什麼不論下載或移除 Docker Image 的時候，都會看到是很多檔案在下載或刪除的緣故。$ docker rmi &amp;lt;Image 名稱或 ID&amp;gt;$ docker rmi nginx八、查看 Container 資訊docker inspect 會傳回一個 JSON 格式的資訊，裡面包括 Container ID、Container 名稱、建立日期、網路配置、使用的 Docker Image、主機配置資訊、資料卷、各項配置參數。# 檢視 Container 所有資訊$ docker inspect &amp;lt;Container 名稱或 ID&amp;gt;因為 docker inspect 資訊很多，所以可以使用 –format 選項，來擷取部分所需的資訊，加上 json 代表傳回的格式是 JSON。# 使用 --format (-f) 選項來擷取 Container 部分資訊# ._____ 代表某個欄位區段，大小寫要和 JSON 資料裡的欄位值完全相同，譬如狀態資訊就是 .State$ docker inspect --format=&#39;{{jason .____}}&#39; &amp;lt;Container 名稱或 ID&amp;gt;# 擷取 Container 狀態資訊，相關資訊會放在 [State] 欄位區段$ docker inspect --format=&#39;{{json .State}}&#39; &amp;lt;Container 名稱或 ID&amp;gt; # 查看 [State] 欄位區段裡的 [Status] 欄位值$ docker inspect --format=&#39;{{json .State.Status}}&#39; &amp;lt;Container 名稱或 ID&amp;gt;九、查看每個 Container 用掉多少硬碟空間最後面的 SIZE 有寫大小。$ docker ps -s 十、查看哪一個 Container 用掉最多資源docker stats 會出現全畫面的”即時” Container 資源使用狀況，Ctrl + C 退出。$ docker stats &amp;lt;Container 名稱或ID&amp;gt;# 加入 -a 列出所有的 Container，可以知道目前機器共有多少個 Container、哪些有在執行、哪些沒有在執行$ docker stats -a十一、查看 Container 的 Log一次只能指定一個 Container，不支援同時查看多個 Container 的 Log 資訊。$ docker logs &amp;lt;Container 名稱或 ID&amp;gt;# 執行一個 nginx Container 後 curl 它，接著查看啟動後到目前為止的 log $ docker run -d -p 8080:80 nginx$ curl http://127.0.0.1:8080$ docker logs 81e3# 使用 --tail 指定最後幾行的 log 行數，查看最後兩行的 log$ docker logs --tail 2 &amp;lt;Container 名稱或 ID&amp;gt;$ docker logs --tail 2 81e3# 使用 --since 查詢倒數幾分鐘以前的 log，查看兩分鐘前的 log$ docker logs --since 2m &amp;lt;Container 名稱或 ID&amp;gt;$ docker logs --since 2m 81e3# 加上 -f 可以查看&quot;即時更新&quot;的 Container log，Ctrl + C 退出$ docker logs -f &amp;lt;Container 名稱或 ID&amp;gt;$ docker logs -f 81e3十二、小技巧1. 停止所有的 containers$ docker stop $(docker ps -a -q) 2. 刪除所有的 containers$ docker rm $(docker ps -a -q)3. 刪除所有的 images$ docker rmi $(docker images -a -q)參考資料 Docker 這樣學才有趣：從入門，到玩直播、挖礦" }, { "title": "閱讀心得(2)：有效到讓人中毒的最強心理學", "url": "/posts/Book-review-2-17/", "categories": "Review", "tags": "book, review", "date": "2022-05-27 00:00:00 +0800", "snippet": "書名：有效到讓人中毒的最強心理學：提防惡用上癮、小心中毒的45個心理學絕技作者：神岡真司出版社：方舟文化出版日期：2020/09/09閱讀心得：　　我覺得這本書最大的好處，是可以初步分析出一個不認識的人”可能”的個性，準確率或許不高，但總比原本的 0% 好一點吧！　　在日常裡，也總會不自覺的照著書上寫的撇步，偷偷觀察別人，在科技化的時代裡，偶爾放下手機，看看身邊的世界，發現不管是人事物都很有趣！　　這本書分為生活、職場、愛情的心理學，分享書上一些不錯的地方： 我們可以向討厭我們的人試著提出一些「瑣碎的要求」，因為對方會覺得想拒絕也很麻煩，最後乾脆就接受了，等對方完成後再向他道謝，對方就會覺得你好像沒有想像中那麼討人厭，可藉此提升你在對方心中的印象。 具有良好的溝通能力、能言善道、善於炒熱氣氛、擅長主持座談會的人，都有一個共通點，就是給人擅長聆聽的印象。 請他人轉交文件時只要附上一張便條，簡單寫上「謝謝你每一次的幫忙」，這份文件就會被優先處理。 表裡如一的態度雖然誠實，但當在運用兩面陳述的技巧時，請先提出缺點，優點則放到後面再說，因為人們對於後來出現的事物，會留下更深刻的印象。一旦顛倒過來，反而造成人們不好的印象。 不知道要吃拉麵還是咖哩飯？遇到這種有選項的問題卻選不出來時，放在後方的選項通常較具有心理層面的影響力，這是「新近效應」。因此咖哩放到後面會比較容易被選上。 要讓人們產生幹勁的兩個條件，分別是「外在動機」（Extrinsic Motivation）與「內在動機」（Intrinsic Motivation）。外在動機來自外界給予的獎勵或地位，可能具有義務性或強制性；內在動機則是指一個人的好奇心、興趣或是開心等心情。 　　" }, { "title": "CentOS 7 安裝 Docker", "url": "/posts/Centos-7-install-Docker-16/", "categories": "Docker", "tags": "centos, docker", "date": "2022-05-26 00:00:00 +0800", "snippet": "使用的環境 系統與使用工具 Centos 7.6 Docker 1.13.1 一、Docker 介紹Docker 是 Container 管理工具。Container 是指利用 Linux 核心提供的技術達到把程式或軟體”包裹在可隔離且獨立執行的環境空間”。Container 比虛擬機器輕巧且具可攜性，因為 Container 可共用 Linux 核心的功能，而虛擬機是完全模擬硬體來達到讓虛擬機器可以獨立執行各種作業系統和軟體。 Docker CE（Docker 社群版)：免費如果只是要在區網內執行 Container，只需要使用 Docker Engine、Docker Compose 者很適合。 Docker EE（Docker 企業版）：付費提供更多整合性的基礎架構及雲端服務，如果需要代管 Docker Images、提供私有 Docker Registry 儲存庫、合併各家雲端服務和自動部署服務，可考慮採用。 二、CentOS 安裝 Docker CE(1) 安裝必要套件$ yum install -y yum-utils \\ device-mapper-persistent-data lvm2(2) 新增Docker官方的stable套件庫(repository)$ yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo(3) 更新 yum 的套件索引$ yum makecache fast(4) 安裝 Docker CE 版$ yum install docker-ce(5) 安裝好之後，啟動系統的 Docker 服務$ systemctl start docker(6) 確認 Docker 版本$ docker version(7) 執行 hello world 程式測試$ docker run hello-world如果 hello-world 有成功顯示，表示已經成功安裝好 Docker！參考資料 Docker 這樣學才有趣：從入門，到玩直播、挖礦" }, { "title": "PHP-FPM 是什麼？", "url": "/posts/PHP-FPM-15/", "categories": "PHP", "tags": "php, php-fpm", "date": "2022-05-05 00:00:00 +0800", "snippet": "使用的環境 系統與使用工具 Centos 7.6 重點整理本篇介紹 PHP-FPM，不過要先從其他小傢伙開始介紹，先放上簡單的重點整理。 項目 介紹 FPM 接收特定 request 並且運行 PHP 腳本產生結果 CGI 介於 HTTP server 與 CGI program 溝通的工具、協定 FastCGI CGI 的改版，其 process 會持續運行，並支援分佈式運行 PHP-FPM 一種實作 FastCGI 的 process manager，原本是 PHP 的補丁，在 PHP 5.3.2 被官方加入 PHP 一、PHP-FPM 基本工作原理圖二、FPM 介紹fpm 是 FastCGI Process Manager 的縮寫。其功能是專門接收特定 request 並且運行 php 腳本產生結果。三、CGI 介紹CGI 是一種協定，為了保證 web server 傳過來的資料是標準格式，簡單來說 CGI 是 web server 與 CGI 程式（如 php, python）間進行 “交談” 的一種工具或協定。在 web server 接收到 request 時，會跟 request 內容進行對應處理，再返回對應的檔案給瀏覽器。比如說：如果 request index.html，web server 會去找到這個檔案再丟給瀏覽器，但這僅限於靜態檔案，如果是像 index.php 這種動態檔案，web server 就會把這個 request 交給 php 解析器處理，php 解析器處理完後再將結果丟回給 web server，這過程 web server 會向 php 解析器傳送 post 或 url 或 http header 等等 CGI 有規定的資料和格式。CGI program 針對每個 HTTP request 都會 fork 一個新的 process 來做事，例如：解析設定文件、初始化執行環境、處理 request 等，然後把這個 process 處理完的結果通過 web server 轉發給用戶，剛剛 fork 出的 process 也隨之退出，如果下次用戶再 request 動態資源，那麼 web server 又再次 fork process，如此周而復始，過程如下：CGI program 的工作流程： 初始化各種相關變數 呼叫並初始化 zend 虛擬機 載入並解析 php.ini 啟動 zend， zend 載入 php 腳本，做語法分析 編譯 php 腳本成 opcode 輸出結果 關閉虛擬機 回傳結果給 web server所以 CGI 的效能很差，因為在 CGI 協議下，每次的 request 都會尋找 php.ini 並進行環境的初始化，很浪費系統資源，每一次 request 都會有啟動和退出的過程（fork-and-execute 模式），所以之後才會誕生 FastCGI。四、FastCGI 介紹FastCGI 是一個協定，Fast + CGI，意思就是加速 CGI，提高傳統 CGI 處理 process 的效能。在第一次啟動 php server 時，FastCGI 會先 fork 一個 master process 來解析設定文件 (/usr/local/php/etc/php-fpm.conf) 並初始化執行環境，然後再 fork 多個 worker process。接下來，master process 會專注 listen port，當 request 過來時就將 request 分配給一個 worker process，然後立即可以接受下一個 request，再分配給下一個 worker process，提高了處理 request 的效率，而且當 worker process 不夠用時，master process 還可以根據設定預先啟動幾個 worker process 等著，若閒置的 worker process 太多時，也會關掉一些，這樣不僅提高了效能，也節省了系統資源。FastCGI 採用 client-server 結構，可以將 web server 和 php 解析服務器分開，同時在腳本解析服務器上啟動一個或者多個腳本解析 process。當 web server 每次遇到動態行程時，可以將其直接交付給 FastCGI process 來執行，然後將得到的結果返回給瀏覽器。這種方式可以讓 web server 專注處理靜態 request ，或者將動態檔案的結果返回給 client 端，提高了整個應用系統的性能。五、PHP-FPM 介紹php-fpm 是對於 FastCGI 協議的具體實現，目的是 web server 跟 php 腳本的溝通。php-fpm 可以啟動多個 child process 來運行 php 腳本，有效的使用多核心 cpu 的效能，而每個 process 並不是 request 執行完就關閉，而是會先閒置，等待處理下一個 request，如果閒置太久，且已經太多 process 都閒置狀態才會關閉，所以不會有反覆啟動 processs 導致資源浪費。php-fpm 負責管理一個 process pool 來處理來自 web server 的 HTTP 動態 request，在 php-fpm 中，master process 負責與 web server 進行通訊，接收 HTTP request，再將 request 轉發給 worker process 進行處理，worker process 主要負責動態 PHP 程式碼，處理完成後，將處理結果返回給 web 服務器，再由 web server 將結果發送給客戶端，這就是 php-fpm 的基本工作原理。按照 FastCGI 的設計方式，在第一次啟動 php-fpm 之後，就會記住當時的 php server 設定，如果之後有進行修改，就要再重新啟動，才能再讀取到更新的設定。此外，php-fpm 能做到平滑重啟，讓伺服器能穩定地提供服務。處理的方式是讓新的 worker 套用新的設定，而舊的 worker 會繼續執行手上的工作，執行完畢就會被終止，再由新的worker接替，透過這樣的方式達到平滑重啟。六、PHP-FPM 啟動、停止、重新啟動指令# php-fpm 的設定檔$ vim /usr/local/php/etc/php-fpm.conf# 啟動 php-fpm$ systemctl start php-fpm.service# 停止 php-fpm$ systemctl stop php-fpm.service# 重新啟動 php-fpm$ systemctl restart php-fpm.service參考資料 php-fpm解讀-進程管理的三種模式 秒懂PHP的FastCGI跟PHP-FPM有什麼關係 CGI、FastCGI 和 PHP-FPM PHP-FPM的三種模式和worker進程、master進程詳解 iT邦幫忙─CGI效能不佳，有沒有簡單的解決方案？" }, { "title": "將 History 指令加上時間戳及使用者資訊", "url": "/posts/Linux-history-command-add-timestamp-and-user-information-14/", "categories": "Linux", "tags": "centos, timestamp", "date": "2022-04-13 00:00:00 +0800", "snippet": "使用的環境 系統與使用工具 Centos 7.6 一、設定方式先上結論，設定方式長這樣：$ export HISTTIMEFORMAT=&quot;%F %T `who am i` &quot;二、輸出結果三、設定解說(1) 日期及時間將 history 指令加上日期及時間，可以用 HISTTIMEFORMAT 這個設定，%F %T 代表日期跟時間。$ export HISTTIMEFORMAT=&quot;%F %T &quot;   說明 範例 %F full date; same as %Y-%m-%d 2022-04-11 %T time; same as %H:%M:%S 10:25:58 (2) 使用者資訊若想顯示當下使用者資訊可以加上 who am i 這個指令， who am i 會顯示使用者名稱、該使用者登入的時間、使用者登入時的 IP。$ export HISTTIMEFORMAT=&quot;%F %T `who am i` &quot; [user@wattt ~]# who am iroot pts/0 2022-04-12 14:45 (x.x.x.x) who am i 指令跟 who -m 指令效果一樣。四、永久設定如果單純在 Shell 輸入 export 那行指令，當下 history 輸出的格式是會生效沒錯，但那只是臨時的，下次登入就沒了。想要永久設定，讓每次登入都有這種格式，那就把他寫進 profile 檔案裡面。# 編輯 /etc/profile$ vim /etc/profile# 在最下面加入export HISTTIMEFORMAT=&quot;%F %T `who am i` &quot;# 保存後吃一下設定$ source /etc/profile# 查看現在 history 指令輸出的樣子$ history大功告成！參考資料 Bash history 加上 日期和時間 Linux 日期格式 – Shell Script 自訂格式" }, { "title": "Tmux－視窗分割的好幫手", "url": "/posts/how-to-use-Tmux-13/", "categories": "Linux", "tags": "centos, tmux", "date": "2022-03-29 00:00:00 +0800", "snippet": "使用的環境 系統與使用工具 Centos 7.6 一、Tmux 介紹Tmux 是一個終端機管理工具，它的概念很簡單，就是在一個終端機下開啟多個 session (會話)，而 session 底下又可以開啟多個 window (視窗)或是 pane (視窗區塊)。 架構 說明 session 執行 Tmux 時都會開啟一個新的 session，每個 session 都是獨立的 window 就是可以看到的畫面，一個 session 裡面可以有多個 window pane 一個 window 切成多個區塊，每個區塊就是一個 pane，通常用來同時觀察多個程式 Tmux 會在同一個 session 下保存 window 和 pane，若暫時離開這個 session，這個動作叫做detaching，若重新連線到這個 session，則叫做attaching。Tmux 會一直維持你上次離開 session 時的狀態，除非主機重開機，或是你自己把 Tmux 或 session 刪掉，才會不見。二、Tmux 功能 分割視窗 同時開啟多個視窗 當遇到 ssh 斷線時，session 會在背景執行，重新連回該 session 就可以回到之前的使用環境三、Session &amp;amp; Window &amp;amp; Pane 圖片解說晚點放上四、安裝及使用 Tmux# 安裝 tumx$ yum install tmux -y# 使用 tmux$ tmux五、Tmux 組合鍵注意事項注意！Tmux 的組合鍵要先按 Ctrl 跟 b 再按其它鍵 不是同時按 Ctrl 跟 b，是先按 Ctrl 再按 b我一開始被這個組合鍵雷了好幾次，還以為是 Tmux 壞掉六、Session 組合鍵及指令 Session 組合鍵 說明 &amp;lt;Ctrl+b&amp;gt; + d 把 session 放到背景並離開 tmux 環境 &amp;lt;Ctrl+b&amp;gt; + $ 重新命名目前的 session &amp;lt;Ctrl+b&amp;gt; + s 以視覺化選單切換 session &amp;lt;Ctrl+b&amp;gt; + L 切換至上一個使用過的 session &amp;lt;Ctrl+b&amp;gt; + ( 切換至上一個 session &amp;lt;Ctrl+b&amp;gt; + ) 切換至下一個 session (1) Session 指令 Session 指令 說明 $ tmux ls 列出目前開啟的 session $ tmux at -t {Session name} 連接到指定的 session $ tmux kill-session -t {Session name} 連接到指定的 session 七、Window 組合鍵 Window 組合鍵 說明 &amp;lt;Ctrl+b&amp;gt; + c 建立新 window 視窗 &amp;lt;Ctrl+b&amp;gt; + w 以視覺化選單切換 window 視窗 &amp;lt;Ctrl+b&amp;gt; + n 切換至下一個 window 視窗 &amp;lt;Ctrl+b&amp;gt; + p 切換至上一個 window 視窗 &amp;lt;Ctrl+b&amp;gt; + 數字鍵 切換至指定的 window 視窗 &amp;lt;Ctrl+b&amp;gt; + x 關閉目前的 window 視窗 &amp;lt;Ctrl+b&amp;gt; + f 在所有 window 視窗中搜尋關鍵字 八、Pane 組合鍵及指令 Pane 組合鍵 說明 &amp;lt;Ctrl+b&amp;gt; + “ 進行水平分割 (上下分割畫面) &amp;lt;Ctrl+b&amp;gt; + % 進行垂直分割 (左右分割畫面) &amp;lt;Ctrl+b&amp;gt; + &amp;lt;方向鍵&amp;gt; 移動到其他 pane &amp;lt;Ctrl+b&amp;gt; + &amp;lt;Space&amp;gt; 切換佈局 &amp;lt;Ctrl+b&amp;gt; + &amp;lt;Alt+方向鍵&amp;gt; 一格為單位的調整 pane 大小 &amp;lt;Ctrl+b&amp;gt; + &amp;lt;Alt+o&amp;gt; 逆時針旋轉當前 pane &amp;lt;Ctrl+b&amp;gt; + &amp;lt;Ctrl+o&amp;gt; 順時針旋轉當前pane &amp;lt;Ctrl+b&amp;gt; + x 關閉目前的 pane &amp;lt;Ctrl+b&amp;gt; + z 全螢幕目前的 pane 參考資料 終端機 session 管理神器 — tmux 從0開始的 Tmux 教學 (二) Linux tmux 終端機管理工具使用教學 終端機管理工具：tmux tpm：tmux 套件管理員" }, { "title": "閱讀心得(1)：一杯熱奶茶的等待", "url": "/posts/Book-review-1-12/", "categories": "Review", "tags": "book, review", "date": "2022-03-25 00:00:00 +0800", "snippet": "書名：一杯熱奶茶的等待作者：詹馥華出版社：初光文化出版日期：2021/11/24（電子書）閱讀心得：　　剛讀這本書的前幾頁就感覺到書裡有種既溫暖又哀傷的氛圍，不管是女主角小華的心理創傷、憂鬱少年阿問在愛情裡無怨無悔的執著，或是可愛小傢伙黃子捷的魅力，都在我腦海裡環繞，想一直繼續看下去。　　故事裡的女主角小華，溫柔善良，因為以前發生的事，讓她在感情方面變得容易退卻、沒自信，還好遇到了男主角黃子捷，讓小華內心防禦的高牆逐漸瓦解，不用多說，他就是個很深情又有魅力的人，在病魔的折磨下，不但沒有放棄，反而比任何人更努力的活著，看著他會讓人覺得這世界上其實還很多美好的地方，不要放棄。再來就是阿問，他真的讓人很心疼，傻到不行，真心希望之後他可以遇到適合的人。　　最搞不懂的就是若蘭這個女生，在友情上貼心又重義氣，但在愛情上卻在有男朋友阿問的情況下還時常跟其他男生出去，甚至讓阿問等了她好幾個晚上。若蘭對於自己的行為是形容她無法只擁有熱奶茶，雖然喜歡熱奶茶的溫暖，但又想嘗試果汁的酸甜滋味，這個花心的傢伙！實在讓人不是很喜歡，但又沒辦法真正討厭。　　這本書就是很平淡的一本書，可能是許多人年輕時的寫照，帶給我不強烈但是持續很久的後勁，而且搞得我好想吃水煎包跟喝熱奶茶。但幸好這個故事的結尾不錯，他們很幸運的找到了自己的天使，天使不代表是一起走一生的人，也可以是改變你的人生並引導接下來的路的明燈。故事已結束，我們人生還再繼續，就努力樂觀的過吧！" }, { "title": "用 rkhunter 把 rootkit 通通抓起來！", "url": "/posts/What-is-rootkit-and-Centos-7-use-rkhunter-11/", "categories": "Linux", "tags": "rootkit, rkhunter, centos", "date": "2022-03-23 00:00:00 +0800", "snippet": "使用的環境 系統與使用工具 Centos 7.6 Rootkit Hunter 1.4.6 一、rootkit 是什麼？rootkit 又被稱為後門程式 (backdoor) 或木馬程式 (trojan)。發現漏洞後與修補程式釋出前的中間空窗期，會被駭客撰寫惡意程式來攻擊該漏洞，他們藉此取得被攻擊主機的控制權，植入木馬程式在受攻擊的主機上，並散播惡意程式，這些惡意程式就被稱為 rootkit。將 rootkit 這名詞拆開分別是 root 跟 kit，root 是 unix 系統中最高權限管理者的名稱，kit 則是工具的意思。由此可知，rootkit 就是被用來攻擊目標主機並取得最高權限的工具，而且還會自我隱藏，不讓真正的管理者發現。二、如何避免受到 rootkit 的攻擊？rootkit 主要是藉由主機的漏洞來攻擊的惡意程式，所以要從可能的地方對症下藥。 關閉不必要的服務 隨時更新主機上各個工具的修補程式 使用軟體工具來檢查主機而今天要來介紹的就是第三點，使用 rkhunter 來檢查電腦裡是否有 rootkit 潛伏。三、rkhunter 介紹rkhunter 是一個檢查運作中的 Unix 機器是否有被植入 Rootkit 的工具。而且顧名思義就是 rootkit hunter，rootkit 獵人，聽起來有夠厲害，而且它非常好上手！rkhunter 的功能： 利用 MD5 編碼來比對檔案的一致性，檢查文件是否改動 rkhunter 在釋出的時候，就已經收集了各大知名的 Linux distributions 的重要檔案的 MD5 編碼 (例如 login, ls, ps, top, w 等檔案)， 並製作成資料庫。 檢查 rootkit 經常攻擊的檔案 檢查是否具有錯誤的檔案權限 (針對 binary files) 檢查隱藏檔案 檢查可疑的核心模組 (LKM/KLD) 作業系統的特殊檢測 檢查已啟動的監聽埠號 (listening port) 特定分析 (String scanner)四、安裝及使用 rkhunter當安裝好並且執行後，rkhunter 就會利用它的資料庫的資料去與當下系統的相關檔案進行比對，若比對的結果有問題，則會顯示警示文字，提供系統管理員分析。# 首先安裝 rkhunter$ yum install rkhunter -y# 更新資料庫檔案$ rkhunter --update# 更新病毒資料庫$ rkhunter --propupd# 讓 rkhunter 自動檢測，就不用測試完一部分後就要按 Enter 才能繼續$ rkhunter --check --skip-keypress# 檢查系統並執行所有測試令 (需按 Enter 下一步)$ rkhunter -c五、rkhunter 其他指令 (有些需配合 -c 使用，自己判斷)# 查看當前版本$ rkhunter -V# 檢查是否有新版本$ rkhunter --versioncheck# 使用 crontab 定期執行檢查 (會自動拿掉彩色輸出)$ rkhunter --cronjob# 將檢測結果用黑白輸出 (在有些情況下，有顏色或延長的顯示符號會有問題)$ rkhunter --nocolors# 僅列出警告訊息，正常訊息不列出$ rkhunter --report-warnings-only # 顯示說明及相關參數用法$ rkhunter -help六、rkhunter 的 設定檔位置/etc/rkhunter.conf七、rkhunter 相關設定# 編輯 rkhunter 設定檔$ vim /etc/rkhunter.conf # 新增白名單，就不會每次都被偵測到有問題SCRIPTWHITELIST = /usr/bin/egrep# 同意的隱藏檔ALLOWHIDDENDIR = /etc/.java # log 檔案位置LOGFILE=/var/log/rkhunter/rkhunter.log 八、rkhunter 的 log 檔位置# 去找吧！都放在那裡了/var/log/rkhunter/# 篩選出有問題的部分$ grep Warning /var/log/rkhunter/rkhunter.log九、rkhunter 例外的錯誤狀態舉例 MD5 編碼這方面：rkhunter 在利用 MD5 編碼比對方面，是利用他本身的 MD5 編碼資料庫與當下的系統相關檔案進行比對，但若當下系統不在 rkhunter 支援的範圍之內，rkhunter 會判斷該檔案有問題。此外，如果是利用 tarball 的方式自行安裝類似 syslogd, ps 等檔案，因為下達的參數不同，所以這些檔案與 rkhunter 的 MD5 資料庫也會不同，所以會被判定有問題。在這種情況下，可以先更新 rkhunter 的資料庫，若問題仍舊存在，可以試著聯絡作者。十、遇到的問題(1) Warning: The file properties have changedWarning: The file properties have changed: File: /usr/bin/whoami Current inode: 266256 Stored inode: 266257如果遇到這個問題，很有可能是跑了系統更新後 inode 值改變可以先去 /var/log/yum.log，確認近期是否有更新過上面被警告的指令確認沒問題後，可以用底下指令重置rkhunter --update --propupd參考資料 rkhunter 木馬&amp;amp;後門偵測 Day 30 RootKit Hunter監測木馬和後門偵測 找出rootkit" }, { "title": "更詳細的 ACL 權限", "url": "/posts/Centos-7-ACL-permission-10/", "categories": "Linux", "tags": "acl permission, centos", "date": "2022-03-16 00:00:00 +0800", "snippet": "使用的環境 系統與使用工具 Centos 7.6 setfacl 2.2.51 一、ACL 權限介紹ACL 是 Access Control List 的縮寫。主要功能是提供比傳統的 owner, group, others 的 read, write, execute 權限之外的更細部權限設定。ACL 可以針對單一使用者、單一檔案或目錄來進行 r, w, x 的權限規範，對於需要特殊權限的使用狀況非常有幫助。二、查看 Linux Kernel 是否啟動 ACL$ dmesg | grep -i acl三、查看 ACL 版本$ setfacl --version四、設定 ACL 權限1、ACL 指令結構setfacl -m 為設定的主要指令與選項。而設定的項目則主要有：針對個人： u:[帳號名稱]:rwx- [資料夾或檔案]針對群組： g:[群組名稱]:rwx- [資料夾或檔案]u::r-- 當帳號或群組名稱沒有寫的時候，代表為檔案擁有者的帳號與群組之意# 參數說明：# -R：遞迴，若是目錄，此選項會讓目錄下的所有都擁有所設定的 ACL 權限# -d：預設權限，在此目錄下新建立的所有會自動的擁有此「預設權限」。原本就存在該目錄內的徑物並不會被此預設權限影響，是新建立的才會2、ACL 指令(1) 遮罩 mask透過 mask 來規範最大允許的權限，可以避免不小心手誤開放超大的權限給使用者或群組。$ setfacl -m m::x /your/file 基本上如果特定使用者有 rx 的權限，但 mask 只有 x 的話，實際上特定使用者可以取得的權限僅有 x 而已。(2) 列出資料夾或檔案的 ACL 權限資訊$ getfacl [folder/file](3) 針對特定使用者設定 ACL 權限讓特定特定使用者 fred 對檔案 grouptest 擁有 r 跟 x 的 ACL 權限。一開始先新增一個 test 檔案，然後查看它的基本權限。$ touch filetest$ ll filetest-rw-r--r-- 1 root root 0 Mar 16 11:24 filetest接下來使用 ACL 權限設定：$ setfacl -m u:fred:rx filetest$ ll test-rw-r-xr--+ 1 root root 0 Mar 16 11:24 filetest*查看 filetest 檔案的 ACL 權限$ getfacl filetest# file: filetest# owner: root# group: rootuser::rw- &amp;lt;==預設的擁有者權限user:fred:r-x &amp;lt;==針對 fred 的權限group::r-- &amp;lt;==預設的群組權限mask::r-x &amp;lt;==預設的 mask 權限other::r--就可以知道 filetest 檔案對於使用者 fred 有另外給 r 跟 x 的權限。(4) 針對特定群組設定 ACL 權限讓特定群組 fredhome 對檔案 grouptest 擁有 w 跟 x 的 ACL 權限。$ touch grouptest$ ll grouptest-rw-r--r-- 1 root root 0 Mar 16 11:35 grouptest接下來使用 ACL 權限設定：$ setfacl -m g:fredhome:wx grouptest$ ll test-rw-rwxr--+ 1 root root 0 Mar 16 11:35 grouptest*查看 grouptest 檔案的 ACL 權限$ getfacl grouptest# file: grouptest# owner: root# group: rootuser::rw-group::r--group:fredhome:-wxmask::rwxother::r--就可以知道 grouptest 檔案對於群組 fredhome 有另外給 w 跟 x 的權限。(5) 移除指定 ACL 權限移除指定的 ACL 權限，可以使用 -x 參數，移除 ACL 權限時不需要指定權限內容。$ setfacl -x u:fred /your/file(6) 刪除所有新增的 ACL 權限但預設的 ACL 規則（owner, group, others）將被保留。$ setfacl -b /your/file(7) 刪除預設的 ACL 權限如果沒有預設規則，將不提示。$ setfacl -k /your/folder(8) 繼承 ACL 權限如果想讓特定資料夾下的新檔案都可以自動繼承特定的 ACL 權限設定，可以在資料夾加上預設的 ACL 權限，預設 ACL 權限的表示法就是在一般 ACL 權限之前加上 d: 或 default:。 要注意此參數 d 只對資料夾有效。# 讓指定的資料夾有給使用者 fred 擁有 r 跟 x 權限的預設 ACL 權限$ setfacl -m d:u:fred:rx /your/folder參考資料 linux ACL權限 [Day 10] Linux 細部權限 ACL 大神親自教你如何用Linux acl命令實現文件權限管理" }, { "title": "Centos 7 安裝 DenyHosts 教學", "url": "/posts/Centos-7-use-Denyhosts-9/", "categories": "Linux", "tags": "centos, denyhosts", "date": "2022-03-15 00:00:00 +0800", "snippet": "使用的環境 系統與使用工具 Centos 7.6 iptables v1.4.21 Python 2.7.5 Python 3.6.8 一、DenyHosts 介紹DenyHosts 是一個防止暴力攻擊 SSH 的工具,當有人想要惡意 try 機器的 SSH 帳號密碼時，它會監看及分析 SSH 的 log file (譬如 /var/log/secure)。當發現同一 IP 連續登入失敗，並達到所設定的條件次數時，就會將嘗試登入的 IP 加入到 /etc/hosts.deny 並作出封鎖。但是它只能單純攔截 ssh 攻擊，若想要比較全面一點的防護可以參考這篇文章 (要放 Fail2ban 的連結)。二、DenyHosts 安裝# 在自己想要的資料夾底下將資料夾 clone 下來 (舉例在 /usr/local 資料夾)$ cd /usr/local$ git clone https://github.com/denyhosts/denyhosts.git # 進入 denyhosts 資料夾$ cd denyhosts# 查看現在的路徑$ pwd# 開始安裝 DenyHosts $ python setup.py install如果安裝後遇到 ImportError: No module named ipaddr 的問題，可以透過安裝 ipaddr 模組來解決。# 要先安裝 python-pip (已安裝過可跳過此步驟)$ yum install python-pip# 安裝 ipaddr 模組$ pip install ipaddr# 然後再安裝一次 DenyHosts $ python setup.py install三、DenyHosts 基本設定(1) DenyHosts 的設定檔/etc/denyhosts.conf(2) 編輯檔案及介紹$ vim /etc/denyhosts.conf# sshd 登入的 log 位置SECURE_LOG = /var/log/secure# 裡面放黑名單 IP 的檔案，預設在 /var/lib/denyhosts# 此篇範例設在 /usr/local/denyhosts/dataWORK_DIR = /usr/local/denyhosts/data# DenyHosts 3.0 後就加入了 iptables 同步封鎖的功能# 如果不要這個功能就將它註解IPTABLES = /sbin/iptables# ssh 的 port，若一個以上的 port 要用逗號分隔 (ex: 11,22,33)BLOCKPORT = 22# 多久清除一次已封鎖的 IPPURGE_DENY = 1w# 是否做域名反解HOSTNAME_LOOKUP = No# 如果登入成功，各個 IP 地址的失敗次數將重置為 0RESET_ON_SUCCESS = yes# 多久執行一次預設清理，設定值與 PURFE_DENY 一樣即可DAEMON_PURGE = 1w# 允許無效用戶登錄失敗的次數DENY_THRESHOLD_INVALID = 5# 允許普通用戶登錄失敗的次數DENY_THRESHOLD_VALID = 10# 允許 root 登錄失敗的次數DENY_THRESHOLD_ROOT = 3四、WORK_DIR 資料夾底下會有的檔案裡面是放黑名單 IP 的檔案。 hosts hosts-restricted hosts-root hosts-valid users-hosts五、解除被封鎖的 IP開啟以下六個檔案，個別手動註解或刪除解封的 IP。# 此篇範例的 WORK_DIR 路徑在 /usr/local/denyhosts/data $ vim /etc/hosts.deny$ vim /usr/local/denyhosts/data/hosts$ vim /usr/local/denyhosts/data/hosts-restricted$ vim /usr/local/denyhosts/data/hosts-root$ vim /usr/local/denyhosts/data/hosts-valid$ vim /usr/local/denyhosts/data/users-hosts也有一些指令可以直接解除被封鎖的 IP，但是實際測試不起作用，所以暫且不談。六、Denyhosts 的白名單 IP 設定若想要設定不想被 DenyHosts 封鎖的 IP，可以建立白名單。在 WORK_DIR 路徑建立一個新檔案 allowed-hosts，檔案內容是一行各一個白名單 IP。這個 IP 還是會在 /etc/hosts.deny 裡面，只是會被註解。# 進入 WORK_DIR 路徑$ cd /usr/local/denyhosts/data# 建立並編輯白名單檔案$ vim allowed-hosts 七、開始使用 Denyhosts1. 啟動 Denyhosts 啟動前，務必要先清空或分割 sshd 的 log 檔，不然自己會先被封鎖。# 要先到 Denyhosts 的資料夾底下，再開始做其他動作$ cd /usr/local/denyhosts# 啟動 Denyhosts$ ./daemon-control-dist start# 重新啟動 Denyhosts$ ./daemon-control-dist restart# 查看 Denyhosts 狀態 $ ./daemon-control-dist status # 停止 Denyhosts$ ./daemon-control-dist stop2. 分割 sshd 的 log 檔 (/var/log/secure)想要馬上分割 /var/log/secure 檔案，可以強制執行 logrotate，而不用等定期的分割時間。logrotate -vf /etc/logrotate.conf 八、若 /var/log/secure 不紀錄 log先試著重新啟動 rsyslog，再觀察看看。$ service rsyslog restart 參考資料 sourceforge DenyHosts Files DenyHosts Github #64 option –purgeip does not work" }, { "title": "檢查 CentOS 7 的系統或服務是否需要重新啟動", "url": "/posts/Centos-7-check-reboot-is-required-8/", "categories": "Linux", "tags": "centos, system", "date": "2022-03-10 00:00:00 +0800", "snippet": "使用的環境 系統與使用工具 Centos 7.6 一、為什麼要關機或重啟服務？Linux 伺服器的系統與軟體更新是定期需要做的工作，某些重要的系統套件在更新完之後，可能會需要重新啟動對應的服務，甚至若有更新到 Linux 核心的時候，還會需要重新開機。而如何判斷哪些服務要重新啟動，以及何時需要重新開機，就是更新後常會遇到的小問題。二、介紹 needs-restarting 工具needs-restarting 是一個 yum-utils 套件中的一個小工具，它可以快速檢查目前的系統狀態，列出需要重新啟動的服務，並且檢查 Linux 核心的版本，判斷是否需要重新開機。三、安裝 needs-restarting 工具(1) 安裝 yum-utils 套件# 使用前先用 yum 安裝 yum-utils 套件 $ yum install yum-utils -y四、檢查作業系統是否需要重新啟動# 搭配 -r 參數可以檢查 Linux 核心版本 $ needs-restarting -r如果輸出的訊息中，有 Reboot is required … 這樣的訊息， 就代表目前運行的 Linux 核心版本過舊，需要重新開機。或是可以用另一種簡單明瞭的方式：$ needs-restarting -r ; echo $?如果是 0 就代表不需要重新開機，而若是 1 則代表需要重新開機(1) 重開機指令# 立即重新開機$ reboot# 指定時間重新開機，舉例 21:30 再重新關機$ shutdown -r 21:30 &amp;amp; 五、檢查服務是否需要重新啟動# 搭配 -s 參數可以列出需要重新啟動的系統服務$ needs-restarting -s若要重新啟動指定的服務，可以使用 systemctl 搭配 restart 參數。例如，重新啟動 sshd：$ systemctl restart sshd六、顯示由當前 UID 建立起的行程$ needs-restarting -r參考資料 CentOS Linux 判斷更新後是否要重新開機？" }, { "title": "Iptables 及常用指令介紹", "url": "/posts/Linux-iptables-7/", "categories": "Linux", "tags": "centos, iptables", "date": "2022-03-09 00:00:00 +0800", "snippet": "使用的環境 系統與使用工具 Centos 7.6 iptables v1.4.21 一、iptables 介紹CentOS 7 的防火牆套件有 iptables 和 firewalld，兩者的核心都是以 netfilter 來實現。可藉由設定規則來過濾傳入或傳出的封包，然後寫好的規則會被送往 netfilter，告訴核心如何去處理封包。而此篇筆記要來介紹 iptables。二、開始使用 iptables1. 安裝 iptablesyum install iptables -y2. 啟動 iptablessystemctl start iptables3. 重新啟動 iptablessystemctl restart iptables4. 查看 iptables 狀態systemctl status iptables5. 停止 iptablessystemctl stop iptables6. 設定開機自動啟動systemctl enable iptables三、iptables 的主要設定檔位置/etc/sysconfig/iptables四、iptables 狀態說明iptables 查看狀態時是 Active: active (exited) 而不是 Active: active (running)去查看 Loaded 時的讀取檔後，可以發現以下這行$ vim /usr/lib/systemd/system/iptables.serviceExecStart=/usr/libexec/iptables/iptables.init start得知當執行 iptables 時是執行 iptables.init start 這個指令 當執行完後就結束了，因此對 systemd 來說是有成功執行 (active)而只要 ExecStart 執行的指令結束後，就會變成 exited沒有 daemon 會持續執行，狀態就會是 active (excited)五、iptables 定義規則的方式 (以下皆可)1. iptables 設定檔直接編輯修改$ vim /etc/sysconfig/iptables若直接修改此檔案，建議修改前先保存目前的防火牆規則規則會自動保存到 /etc/sysconfig/iptables# 此命令保存的規則開機會自動生效$ service iptables save修改後要重新啟動 iptables$ systemctl restart iptables2. 用 iptables-restore 還原先前已保存的規則iptables 還原3. 使用 iptables 指令底下有介紹iptables 指令六、iptables 結構iptables 主要分為三個部分： Tables (表)：就是一份防火牆的規則表，可包含多組 Chain Chains (鏈)：是 Rules 規則的鏈群組，可包含多個 Rule Rules (規則)：每一個單獨設立的規則七、iptables 預設的三個 Tables內建的 Tables 有三個，分別是 nat、mangle和 filter，當未指定規則表時，則一律視為是 filter。另外，還有兩個 Tables (raw、security) 暫時先不談。 Tables 包含的 Chains 與功能 filter INPUT、OUTPUT、FORWARD   最常用的 table，一般的過濾功能 nat PREROUTING、POSTROUTING   全名是 Network Address Translation 的縮寫，主要在進行來源與目的之 IP 或 port 的轉換，或是處理 Routing 轉換前/後的封包   與 Linux 本機較無關，主要與 Linux 主機後的區域網路內電腦較有相關 mangle INPUT、OUTPUT、FORWARD、PREROUTING、POSTROUTING   主要是與特殊的封包的路由旗標有關，可以修改封包的 IP 位址及其他值   早期僅有 PREROUTING 及 OUTPUT，不過從 kernel 2.4.18 之後加入了 INPUT 及 FORWARD   由於這個表格與特殊旗標相關性較高，所以在單純的環境當中，較少使用 mangle 這個表格 八、五種階段的 Chains 介紹 INPUT：經網卡進入的封包 OUTPUT：經網卡出去的封包 FORWARD：經網卡進入 / 出去轉送的封包 (proxy 類型) PREROUTING：改變經網卡進入的封包狀態 (DNAT / REDIRECT) POSTROUTING：改變經網卡出去的封包狀態 (SNAT / MASQUERADE) FORWARD 處理的封包會繞過 INPUT 和 OUTPUT，因為處理路徑不同九、iptables 處理流程 當封包進入網卡後，會先進入 PREROUTING，然後根據目的地址進行路由決策，如果目的地址是本機，就會走 INPUT，不是本機則走 FORWARD，然後再走 POSTROUTING 轉出去。 進入 INPUT 的封包會轉給本機的程式，程式處理後會傳送新的封包，走 OUTPUT，然後經過 POSTROUTING 轉出去。 過程中，當封包每經過一個 chain，都要按照 chain 的 rule 順序來走，只要遇到一個 match 的 rule 就要按照這個 rule 進行處理，而後面的 rule 對這個封包資料就不再起作用。 十、iptables 指令用 iptables 指令新增的規則會立即生效，不用重新啟動服務1. iptables 備份$ iptables-save &amp;gt; /your-path/iptables-backup.bak2. iptables 還原# 鳥哥建議使用 iptables-save 這個指令來觀察防火牆規則，因為 iptables-save 會列出完整的防火牆規則，只是並沒有規格化輸出而已$ iptables-restore &amp;lt; /your-path/iptables-backup.bak3. 列出預設 filter 表格的三個鏈的規則$ iptables -L -n# 單獨列出 nat 表格的規則$ iptables -t nat -L -n# 參數說明：# -L ：列出目前的 table 的規則# -n ：不進行 IP 與 hostname 的反查，速度較快# -t ：用來指定規則表輸出的結果解釋： target：代表進行的動作， ACCEPT (接受)、REJECT (拒絕)以及 DROP (丟棄) prot：代表使用的封包協定，主要有 tcp、udp 以及 icmp 三種封包格式 opt：額外的選項說明 source ：代表此規則是針對哪個『來源 IP』進行限制 destination ：代表此規則是針對哪個『目標 IP』進行限制4. 顯示 iptables 版本$ iptables -V5. 刪除所有的規則$ iptables -F6. 刪除指定的 chain$ iptables -X7. 將 iptables 計數器歸零$ iptables -Z8. 新增規則 (放在所有規則的最後面)$ iptables -A9. 新增規則 (放在指定規則的上一行，沒有指定就放第一行)$ iptables -I10. 刪除某條規則 (指定行數)$ iptables -D INPUT 111. 查看指令行數$ iptables --line-numbers -L INPUT12. 定義 chain 的預設過濾政策# 設定預訂政策 INPUT 為丟棄$ iptables -P INPUT DROP# 設定預訂政策 OUTPUT 為接受$ iptables -P OUTPUT ACCEPT# 設定預訂政策 FORWARD 為接受$ iptables -P FORWARD ACCEPT十一、iptables 那些比較長的指令1. 允許來自 lo 介面的封包# 不論封包來自何處或去到哪裡，只要是來自 lo (loopback) 這個介面，就予以接受$ iptables -A INPUT -i lo -j ACCEPT2. 接受由本機發出的回應封包$ iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT# 參數說明：# -m ： iptables 的外掛模組，主要有：state (狀態模組)、mac (網路卡硬體位址)# --state ：一些封包的狀態，主要有：INVALID (無效)、ESTABLISHED (連線成功)、NEW (新建立連線)、RELATED (最常用，主機發送出去的封包)(3) 讓 icmp 封包變成可接受的封包類型$ iptables -A INPUT -p icmp -m icmp --icmp-type 8 -j ACCEPT(4) 開啟 22/80/443 port$ iptables -A INPUT -p tcp --dport 22 -j ACCEPT$ iptables -A INPUT -p tcp --dport 80 -j ACCEPT$ iptables -A INPUT -p tcp --dport 443 -j ACCEPT(5) 阻擋來自特定 IP 或 port 號的封包# 阻擋來自 192.168.1.0/24 的 1024:65535 埠口的封包，且想要連線到本機的 ssh port$ iptables -A INPUT -i eth0 -p tcp -s 192.168.1.0/24 --sport 1024:65534 --dport ssh -j DROP# 參數說明：# -p 協定：設定此規則適用於哪種封包格式，主要的封包格式有：tcp、udp、icmp 以及 all# --sport / -s ：限制來源 port，port可連續，ex 1024:65535# --dport / -d ：限制目標 port# -j ：後面接動作，主要的動作有ACCEPT、DROP、REJECT及LOG參考資料 IPTABLES 應用與管理 [Ubuntu]iptables 設定 iptables iptables系列教程（一）iptables入門篇 邁向 RHCE 之路 (Day22) - IPTables 防火牆 iptables基礎原理和使用簡介" }, { "title": "使用 Fish Shell 讓你的 Linux CLI 比別人更炫炮！", "url": "/posts/CentOS-7-install-fish-shell-6/", "categories": "Linux", "tags": "centos, shell", "date": "2022-03-04 00:00:00 +0800", "snippet": "使用的環境 系統與使用工具 Centos 7.6 fish, version 2.7.1 git version 2.31.1 一、Fish Shell 介紹Fish Shell 是個互動式 Shell，可以讓指令介面 (CLI, Command Line Interface) 變得更好看，又有指令自動補全功能的一個工具，非常方便。二、oh-my-fish 介紹oh-my-fish 是 Fish Shell 的框架，允許安裝擴充套件或是更改 Fish Shell 的主題，簡單使用又快速。三、檢查 Git 版本# 查看原本的 git 版本，如果低於 1.9.5 就得升級$ git --version# 升級 git $ yum remove git $ yum install http://opensource.wandisco.com/centos/7/git/x86_64/wandisco-git-release-7-2.noarch.rpm$ yum install git $ git --version四、安裝 Fish Shell$ cd /etc/yum.repos.d/$ wget https://download.opensuse.org/repositories/shells:/fish:/release:/2/CentOS_7/shells:fish:release:2.repo$ yum install fish五、安裝 oh-my-fish$ curl https://raw.githubusercontent.com/oh-my-fish/oh-my-fish/master/bin/install | fish六、進入 Fish Shell 後使用 oh-my-fish$ fish$ omf七、暫定先用 agnoster 這個主題# 下載 agnoster 主題$ omf install agnoster# 正常下載後就會自動套用，若沒有套用就輸入下面這行$ omf theme agnoster八、更改主題顏色$ vim /root/.local/share/omf/themes/agnoster/functions/fish_prompt.fish找到 Color setting 這個區塊，裡面有一些東西可以調資料夾背景色是這個set -q color_dir_bg; or set color_dir_bg green預設可以支援的顏色有這些Valid colors include:black, red, green, yellow, blue, magenta, cyan, whitebrblack, brred, brgreen, bryellow, brblue, brmagenta, brcyan, brwhite設定完後要 reload omf$ omf reload完成！可以開始用美美德 fish shell 惹。參考資料 fish-shell Github oh-my-fish Github Fish shell：讓指令更接近懶人使用" }, { "title": "有關 Review 這個分類項目", "url": "/posts/The-first-post-in-review-5/", "categories": "Review", "tags": "review", "date": "2022-02-25 00:00:00 +0800", "snippet": "Review之後我打算將閱讀或各種心得放在 Review 這個分類裡。review 這個字的意思比較接近「評論」，特別是指針對書、電影、戲劇給予的意見，通常會涉及討論作品的優缺點，甚至是推薦與否。而現在對於產品、餐廳、活動的評論也是用 review 這個字， 像是 Google 地圖上對於地點的評論、Amazon 網站上消費者對於產品的使用心得都適用 review。翻成中文的例子可以接近為：書評/讀書心得、影評/電影心得、產品使用心得、食物心得等等。來學學 Review 的英文用法吧要表達「…的評論」會用 review of…。I always read film reviews before watching films.我在看電影之前一定會先去看影評。What’s your review of the book “The Secret”?你對於《秘密》這本書的評論/心得為何？After I read the reviews of the camera, I decided not to buy it.在我看過那台相機的評論之後，我決定不買它了。參考資料 「心得、感想、想法」英文怎麼說？thoughts? ideas?" }, { "title": "MySQL 8.0 指令", "url": "/posts/MySQL-8-0-commands-4/", "categories": "MySQL", "tags": "mysql, centos", "date": "2022-02-23 00:00:00 +0800", "snippet": "使用的環境 系統與使用工具 Centos 7.6 MySQL 8.0.13 一、進入資料庫# 這個是在終端機上下指令$ mysql -u &amp;lt;USER&amp;gt; -p二、使用者(1) 查詢資料庫使用者SELECT User FROM mysql.user;(2) 查詢資料庫使用者（刪除重複的）SELECT DISTINCT User FROM mysql.user;(3) 查詢資料庫使用者與來源主機SELECT User, Host FROM mysql.user;(4) 建立使用者帳號，並設定密碼CREATE USER &#39;[USER]&#39;@&#39;[x.x.x.x]&#39; IDENTIFIED BY &#39;[PASSWORD]&#39;;(5) 更改使用者密碼ALTER USER &#39;[USER]&#39;@&#39;[x.x.x.x] IDENTIFIED BY &#39;[NEW_PASSWORD]&#39;;# 讓設定生效FLUSH PRIVILEGES;(6) 查詢使用者的細部權限SHOW GRANTS FOR &#39;[USER]&#39;@&#39;[x.x.x.x]&#39;;(7) 刪除使用者DROP USER &#39;[USER]&#39;@&#39;[x.x.x.x]&#39;;(8) MySQL 使用者連線# USER@ 後面的 ip 是要連到資料庫的 web 主機 ip# 先建立使用者CREATE USER &#39;[USER]&#39;@&#39;[X.X.X.X]&#39; IDENTIFIED BY &#39;[PASSWORD]&#39;;# 選擇資料庫USE [DATABASES];# 給使用者權限GRANT ALL PRIVILEGES ON *.* TO &#39;[USER]&#39;@&#39;[x.x.x.x]&#39; WITH GRANT OPTION;# 讓設定生效FLUSH PRIVILEGES;三、資料庫(1) 新增資料庫CREATE DATABASE `[DATABASE_NAME]`;(2) 列出所有資料庫SHOW DATABASES;(3) 刪除資料庫DROP DATABASE [DATABASE_NAME];(4) 使用資料庫USE [DATABASE_NAME];(5) 查看所有資料庫的使用大小（MB）SELECT TABLE_SCHEMA `DATABASE`, SUM(DATA_LENGTH + INDEX_LENGTH)/1024/1024 &quot;SIZE IN MB&quot; FROM INFORMATION_SCHEMA.TABLES GROUP BY TABLE_SCHEMA;(6) 查看某資料庫的使用大小SELECT TABLE_SCHEMA `DATABASE`, SUM(DATA_LENGTH + INDEX_LENGTH)/1024/1024 &quot;SIZE IN MB&quot; FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA=`[DATABASE_NAME]` GROUP BY TABLE_SCHEMA;四、資料表(1) 列出資料表SHOW TABLES;(2) 列出資料表的內容SELECT * FROM [TABLE_NAME];(3) 刪除資料表DROP TABLE [TABLE_NAME];(4) 清空資料表（只清除資料並保留結構、欄位、索引）TRUNCATE TABLE [TABLE_NAME];(5) 查看某資料庫的所有資料表的使用大小SELECT TABLE_NAME AS &quot;TABLE&quot;, ROUND(((DATA_LENGTH + INDEX_LENGTH) / 1024 / 1024), 2) AS &quot;SIZE (MB)&quot; FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = [DATABASE_NAME]&quot; ORDER BY (DATA_LENGTH + INDEX_LENGTH) DESC;五、進階語法(1) 查看正在執行的行程SHOW PROCESSLIST;(2) 查看 Master 狀態SHOW MASTER STATUS;(3) 查看 Slave 狀態SHOW SLAVE STATUS\\G;(4) 查看 binlog 狀態SHOW BINARY LOGS;(5) 清除過時的 binlog# 將刪除 mysql-bin.000001 ~ mysql-bin.000005 的 binlogPURGE BINARY LOGS TO &#39;mysql-bin.000006&#39;;六、MySQL mysqldump（資料匯出工具）語法要在終端機上面下指令(1) 備份某個資料庫# 這樣的匯出檔案，沒有create database選項，只有create table選項$ mysqldump -u root -p [DATABASE_NAME] &amp;gt; [DATABASE_NAME].sql;(2) 還原某個資料庫（需先建好還原資料庫）# 需先建好還原資料庫$ mysql -u root -p [DATABASE_NAME] &amp;lt; [DATABASE_NAME].sql;(3) 備份所有資料庫# 這樣的匯出檔案，有 create database 選項，也有 create table 選項$ mysqldump -u root -p --all-databases &amp;gt; all_db_backup.sql;(4) 還原多個資料庫# 檢查匯出 all_db_backup.sql 內是否已有 CREATE DATABASE 指令，有才可進行還原，沒有的話則要先去建好還原資料庫$ mysql -u root -p &amp;lt; all_db_backup.sql(5) 輸出 SQL 結構$ mysqldump -u root -p --no-data --all-databases &amp;gt; list.sql# 和底下這個指令效果一樣$ mysqldump -u root -p -d --all-databases &amp;gt; list.sql(6) 備份資料庫中的某個資料表$ mysqldump -u root -p [DATABASE_NAME] [TABLE_NAME] &amp;gt; db_table_backup.sql;(7) 備份資料庫中的多個資料表$ mysqldump -u root -p [DATABASE_NAME] [TABLE_NAME1] [TABLE_NAME2] [TABLE_NAME3] &amp;gt; db_table_backup.sql;(8) 還原加上字元編碼參數$ mysql -u root -p --default-character-set=utf8 [DATABASE_NAME] &amp;lt; [DATABASE_NAME]_backup.sql(9) 輸出 schema$ mysqldump [DATABASE_NAME] --no-data &amp;gt; [DATABASE_NAME]_schema.sql七、MySQL mysqladmin（管理工具）語法尚未 :P八、MySQL mysqlbinlog（管理日誌工具）語法尚未 :P參考資料 查詢 MySQL/MariaDB 資料庫的使用者帳號教學 在 Ubuntu ≥ 18.04 使用密碼登入 MySQL 及建立資料庫 MySQL 指令、語法及管理" }, { "title": "在 MacOS 上安裝 Ruby 與 Jekyll", "url": "/posts/MacOS-install-ruby-and-jekyll-to-create-Github-Pages-3/", "categories": "GitHub Pages", "tags": "macos, github pages, ruby, jekyll", "date": "2022-02-21 00:00:00 +0800", "snippet": "使用的環境 系統與使用工具 MacOS Mojave 10.14.6 Ruby 2.7.5 一、Jekyll 介紹Jekyll 是用 Ruby 撰寫的靜態部落格框架，可以將靜態網站的 Markdown 語法轉成 HTML 語法。靜態網頁就是不包含資料庫，也不能和使用者互動的單純網頁，通常內容也不會時常變動。因此，Jekyll 對於要發展部落格的使用者來說非常方便。(1) MacOS Install HomebrewHomebrew 是軟體套件管理系統，支援 MacOS 和 Linux，非常好用，大推！如果是使用 Ubuntu 或 CentOS 或其他版本的 Linux，可以不用裝 Homebrew# MacOS Install Homebrew$ /bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;# 若已經安裝過 Homebrew 則需要更新$ brew update(2) Install Ruby若使用 brew install ruby 安裝 ruby 會安裝到最新版 ruby 3但測試好幾次使用 ruby 3 的話，啟動 jekyll 會有錯誤所以我用另外的方式安裝 ruby 2.7.5$ curl -fsSL https://github.com/rbenv/rbenv-installer/raw/HEAD/bin/rbenv-installer | bash# 因為我是使用 oh-my-zsh，若是使用 bash/dash 要將 ~/.zshrc 改成 ~/.bashrc$ echo &#39;export PATH=&quot;$HOME/.rbenv/bin:$PATH&quot;&#39; &amp;gt;&amp;gt; ~/.zshrc $ echo &#39;eval &quot;$(rbenv init -)&quot;&#39; &amp;gt;&amp;gt; ~/.zshrc$ source ~/.zshrc$ exec $SHELL$ rbenv install -l# ruby 版本我選 2.7.5$ rbenv install [ruby-version] $ rbenv global [ruby-version] 安裝完後檢查一下有沒有安裝正常# 安裝成功後，查看 ruby 跟 gem 的版本$ ruby -v$ gem -v(3) Install jekyll 和 bundler$ gem update$ gem install jekyll bundler# 安裝成功後，查看 jekyll 和 bundle 的版本$ jekyll -v$ bundle -v(4) 使用 minimal-mistakes 主題也可以去下載其他主題，現在先以 minimal-mistakes 作為示範$ git clone https://github.com/mmistakes/minimal-mistakes.git# 進入資料夾$ cd minimal-mistakes$ bundle install(5) 執行 Jekyll# 啟動 Jekyll 有兩種指令方式，兩種都可以用！$ jekyll serve# 或是$ bundle exec jekyll serve看到 Server running… press ctrl-c to stop… 就表示成功！(6) 在瀏覽器上打 http://127.0.0.1:4000完成！就可以看到目前主題的樣子了這時候就可以參考 官方文件 上的教學去更改主題的設定可以新增主選單、主題或是更改樣式自由發揮！二、Github PagesGiuhub Pages 教學請看 此篇文章若是 clone 別人的主題，記得在 push 時不能直接 push 喔，因為那是別人的 Repo！如果是使用 Github Desktop，記得按 Repository Setting -&amp;gt; Remote -&amp;gt; Primary remote repositoey (origin)在欄內輸入自己的 Github Pages 的 Repo 的網址，成功在 Github Desktop 上顯示後再 push 上去喔～參考資料 Minimal Mistakes Quick-Start Guide 如何用 Jekyll 建立一個靜態網站？ - GitHub Pages x Jekyll x Blog" }, { "title": "Github Pages 設定", "url": "/posts/How-to-use-Github-Pages-2/", "categories": "GitHub Pages", "tags": "gitHub pages", "date": "2022-02-21 00:00:00 +0800", "snippet": "Github Pages 介紹GitHub Pages 是 GitHub 提供的一個網頁代管服務，可以讓使用者放靜態網站，做出個人部落格。 優點 穩定 安全 免費 缺點 僅能呈現靜態頁面內容 僅能使用 Git 上傳 GitHub Pages 的 Repo 都是公開的 一、Github Pages 設定(1) 建立一個想作為 Github Pages 的 Repo按下最右邊綠色的 NewRepository name 打上你想要的專案名專案名後面加上 .github.io，方便辨識這是 Github Pages 的專案Description (optional) 是描述你的專案，可以選擇寫或不寫其他的設定都不太用調整好了後就按最下面的Create Repository(2) Repo 建立成功看到這個畫面表示你已經成功建立你的 Repo 了可以先試著新增一個檔案，按下creating a new file名稱跟內容可以先隨便打，反正可以刪掉比較需要注意的是底下的 Commit new file，要描述一下你這個檔案是什麼都用好後按下Commit new file(3) 開始設定 Github Pages按最右邊的Settings再按左側選單的PagesBranch 可以先選None，也可以選擇其他分支（範例選 main）再按下Save如果要使用 Github 內建的主題，就按下Choose a theme我選 Dinky 主題當範例，然後按下Select theme（如果想學習用更方便的主題工具，請按 用 GitHub Pages 建立個人部落格吧！(2)－在 MacOS 上安裝 Ruby 與 Jekyll）接著會跳出一個 index.md，寫一下描述後按下Commit Change就完成了！(4) 訪問你的 Github PagesGithub Pages 的 網址是 [USERNAME].github.io像這樣leewan555.github.io平常只要這樣打就可以進入你的 Github Pages 頁面但由於現在是示範的狀態，所以我會有兩個 Github Pages 的 Repo所以我得在後面再加個 Repo 名稱[USERNAME].github.io/[REPO_NAME]因此我的網址就會是leewan555.github.io/test.github.io進去後會發現網頁自動轉了 https自己的部落格就出現了！參考資料 如何用 GitHub Pages 建立部落格？ - GitHub Pages x Jekyll x Blog 透過 Jekyll 與 GitHub Pages 建立自己的部落格(1) 用 Jekyll 和 Github Page 來架設靜態 Markdown 部落格" }, { "title": "Welcome to Fred&#39;s Blog!", "url": "/posts/Welcome-to-jekyll-1/", "categories": "Jekyll", "tags": "jeykll, gitHub pages", "date": "2022-02-18 00:00:00 +0800", "snippet": "Hi我今天透過 GitHub Pages 建立了個人部落格，部落格是透過 jekyll 生成的，主要參考的 jekyll 主題是 Chirpy。這是我第一篇部落格文章。" } ]
